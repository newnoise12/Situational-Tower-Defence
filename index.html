<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<title>MALL MANAGER '89</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=VT323&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
<style>
:root {
  --neon-pink:    #ff2d78;
  --neon-cyan:    #00f5ff;
  --neon-purple:  #bf00ff;
  --neon-yellow:  #ffe600;
  --neon-green:   #00ff9f;
  --dark-bg:      #0d0015;
  --panel-bg:     #120020;
  --panel-border: #3a006f;
  --text-main:    #e8d5ff;
  --text-dim:     #8866aa;
  --glow-pink:    0 0 8px #ff2d78, 0 0 20px rgba(255,45,120,0.4);
  --glow-cyan:    0 0 8px #00f5ff, 0 0 20px rgba(0,245,255,0.4);
  --glow-purple:  0 0 8px #bf00ff, 0 0 20px rgba(191,0,255,0.3);
}

@font-face{}

* { box-sizing: border-box; }

body {
  margin: 0;
  background: var(--dark-bg);
  color: var(--text-main);
  font-family: 'VT323', monospace;
  font-size: 16px;
  display: flex;
  height: 100vh;
  overflow: hidden;
  letter-spacing: 0.03em;
}

/* Scanline overlay on body */
body::after {
  content: '';
  position: fixed;
  inset: 0;
  background: repeating-linear-gradient(
    0deg,
    transparent,
    transparent 2px,
    rgba(0,0,0,0.07) 2px,
    rgba(0,0,0,0.07) 4px
  );
  pointer-events: none;
  z-index: 9998;
}

/* ‚îÄ‚îÄ LEFT PANEL ‚îÄ‚îÄ */
#ui {
  width: 320px;
  background: var(--panel-bg);
  border-right: 1px solid var(--panel-border);
  padding: 12px;
  overflow-y: auto;
  position: relative;
}

#ui::before {
  content: 'MALL MANAGER  º89';
  display: block;
  font-family: 'Orbitron', sans-serif;
  font-weight: 900;
  font-size: 14px;
  color: var(--neon-pink);
  text-shadow: var(--glow-pink);
  letter-spacing: 0.12em;
  text-align: center;
  padding: 8px 0 10px;
  border-bottom: 1px solid var(--panel-border);
  margin-bottom: 10px;
}

/* ‚îÄ‚îÄ CENTER CANVAS ‚îÄ‚îÄ */
#game {
  flex: 1;
  display: block;
}

/* ‚îÄ‚îÄ RIGHT PANEL ‚îÄ‚îÄ */
#analyticsBox {
  width: 260px;
  background: var(--panel-bg);
  border-left: 1px solid var(--panel-border);
  padding: 12px;
  overflow-y: auto;
}

#analyticsBox h3 {
  margin: 0 0 8px 0;
  font-family: 'Orbitron', sans-serif;
  font-size: 11px;
  color: var(--neon-cyan);
  text-shadow: var(--glow-cyan);
  letter-spacing: 0.1em;
}

.rightTabs {
  display: flex;
  gap: 6px;
  margin-bottom: 10px;
}
.rightTabs button {
  flex: 1;
  padding: 6px 4px;
  margin: 0;
  font-size: 13px;
}

/* ‚îÄ‚îÄ BUTTONS ‚îÄ‚îÄ */
button {
  width: 100%;
  margin-top: 6px;
  padding: 7px 10px;
  background: transparent;
  border: 1px solid var(--neon-purple);
  color: var(--neon-cyan);
  font-family: 'VT323', monospace;
  font-size: 16px;
  letter-spacing: 0.08em;
  cursor: pointer;
  transition: all 0.15s ease;
  text-shadow: 0 0 6px var(--neon-cyan);
  position: relative;
}

button:hover {
  background: rgba(0,245,255,0.08);
  border-color: var(--neon-cyan);
  box-shadow: var(--glow-cyan), inset 0 0 12px rgba(0,245,255,0.06);
  color: #fff;
}

button:disabled {
  opacity: 0.35;
  cursor: not-allowed;
  text-shadow: none;
}

button[onclick*="resetGame"] {
  border-color: var(--neon-pink);
  color: var(--neon-pink);
  text-shadow: var(--glow-pink);
}
button[onclick*="resetGame"]:hover {
  background: rgba(255,45,120,0.1);
  box-shadow: var(--glow-pink);
}

/* Start Wave button ‚Äî extra pop */
button[onclick="startWave()"] {
  border-color: var(--neon-green);
  color: var(--neon-green);
  font-family: 'Orbitron', sans-serif;
  font-weight: 700;
  font-size: 13px;
  letter-spacing: 0.1em;
  text-shadow: 0 0 8px var(--neon-green);
}
button[onclick="startWave()"]:hover {
  background: rgba(0,255,159,0.1);
  box-shadow: 0 0 12px var(--neon-green), 0 0 30px rgba(0,255,159,0.25);
}

/* ‚îÄ‚îÄ STATS ‚îÄ‚îÄ */
.stat {
  margin: 5px 0;
  color: var(--text-main);
  font-size: 17px;
}

.stat span {
  color: var(--neon-yellow);
  text-shadow: 0 0 6px rgba(255,230,0,0.5);
}

#repTier {
  font-size: 13px;
}

/* ‚îÄ‚îÄ DIVIDER ‚îÄ‚îÄ */
hr {
  border: none;
  border-top: 1px solid var(--panel-border);
  margin: 10px 0;
}

/* ‚îÄ‚îÄ SHOP BLOCK ‚îÄ‚îÄ */
.shopBlock {
  margin-top: 12px;
  border-top: 1px solid var(--panel-border);
  padding-top: 8px;
}

/* ‚îÄ‚îÄ TEXT SIZES ‚îÄ‚îÄ */
.small {
  font-size: 13px;
  color: var(--text-dim);
}

.muted {
  color: var(--text-dim);
  font-size: 13px;
}

/* ‚îÄ‚îÄ ROW ‚îÄ‚îÄ */
.row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}

/* ‚îÄ‚îÄ INFO BUTTON ‚îÄ‚îÄ */
.infoBtn {
  width: auto;
  padding: 2px 8px;
  margin: 0;
  font-size: 14px;
  cursor: pointer;
  background: transparent;
  border: 1px solid var(--panel-border);
  color: var(--text-dim);
  border-radius: 4px;
  transition: all 0.15s;
}
.infoBtn:hover {
  border-color: var(--neon-purple);
  color: var(--neon-purple);
  box-shadow: var(--glow-purple);
  background: transparent;
}

/* ‚îÄ‚îÄ TOOLTIP ‚îÄ‚îÄ */
#tooltip {
  position: fixed;
  pointer-events: none;
  background: rgba(13,0,21,0.97);
  border: 1px solid var(--neon-purple);
  box-shadow: var(--glow-purple);
  padding: 8px 12px;
  border-radius: 4px;
  font-family: 'VT323', monospace;
  font-size: 15px;
  color: var(--text-main);
  max-width: 260px;
  line-height: 1.4;
  display: none;
  z-index: 9999;
}
#tooltip .muted { color: var(--text-dim); font-size: 13px; }

/* ‚îÄ‚îÄ THREAT INTEL ‚îÄ‚îÄ */
#threatIntelPanel {
  border: 1px solid rgba(191,0,255,0.3);
  background: rgba(191,0,255,0.05) !important;
}

/* ‚îÄ‚îÄ SCROLLBAR ‚îÄ‚îÄ */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: var(--dark-bg); }
::-webkit-scrollbar-thumb {
  background: var(--neon-purple);
  border-radius: 3px;
  box-shadow: var(--glow-purple);
}

/* ‚îÄ‚îÄ WAVE/PHASE LABEL ‚îÄ‚îÄ */
#phaseDisplay {
  color: var(--neon-cyan);
  text-shadow: var(--glow-cyan);
}

#waveNum {
  color: var(--neon-yellow);
  text-shadow: 0 0 6px rgba(255,230,0,0.5);
}

/* ‚îÄ‚îÄ EVENT NOTIFICATION ‚îÄ‚îÄ */
#eventNotification {
  font-family: 'Orbitron', sans-serif !important;
  font-size: 13px !important;
  letter-spacing: 0.08em;
}

/* ‚îÄ‚îÄ MOBILE BOTTOM NAV ‚îÄ‚îÄ */
#mobileNav {
  display: none;
  position: fixed;
  bottom: 0; left: 0; right: 0;
  height: 52px;
  background: var(--panel-bg);
  border-top: 1px solid var(--panel-border);
  z-index: 200;
  display: flex;
}

#mobileNav button {
  flex: 1;
  margin: 0;
  border: none;
  border-right: 1px solid var(--panel-border);
  border-radius: 0;
  padding: 0;
  font-size: 11px;
  letter-spacing: 0.05em;
  color: var(--text-dim);
  text-shadow: none;
  background: transparent;
}
#mobileNav button:last-child { border-right: none; }
#mobileNav button.active {
  color: var(--neon-cyan);
  text-shadow: var(--glow-cyan);
  background: rgba(0,245,255,0.05);
}
#mobileNav button:hover {
  background: rgba(0,245,255,0.05);
  box-shadow: none;
}

/* ‚îÄ‚îÄ MOBILE DRAWER ‚îÄ‚îÄ */
#mobileDrawer {
  display: none;
  position: fixed;
  bottom: 52px; left: 0; right: 0;
  height: 45vh;
  background: var(--panel-bg);
  border-top: 2px solid var(--neon-purple);
  box-shadow: 0 -4px 30px rgba(191,0,255,0.25);
  z-index: 199;
  overflow-y: auto;
  padding: 12px;
  transition: transform 0.25s ease;
}
#mobileDrawer.hidden {
  transform: translateY(100%);
}

/* ‚îÄ‚îÄ MOBILE STATS BAR ‚îÄ‚îÄ */
#mobileStats {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0;
  height: 44px;
  background: var(--panel-bg);
  border-bottom: 1px solid var(--panel-border);
  z-index: 200;
  align-items: center;
  padding: 0 10px;
  gap: 10px;
  font-size: 14px;
  overflow: hidden;
}
#mobileStats .mStat {
  white-space: nowrap;
  color: var(--text-main);
}
#mobileStats .mStat span {
  color: var(--neon-yellow);
  text-shadow: 0 0 6px rgba(255,230,0,0.5);
}
#mobileStats #mStartWave {
  margin: 0;
  padding: 4px 10px;
  width: auto;
  flex-shrink: 0;
  font-size: 11px;
  font-family: 'Orbitron', sans-serif;
  font-weight: 700;
  letter-spacing: 0.08em;
  border-color: var(--neon-green);
  color: var(--neon-green);
  text-shadow: 0 0 6px var(--neon-green);
}
#mobileStats #mStartWave:hover {
  background: rgba(0,255,159,0.1);
}

/* ‚îÄ‚îÄ RESPONSIVE BREAKPOINT ‚îÄ‚îÄ */
@media (max-width: 768px) {
  body {
    flex-direction: column;
    height: 100dvh;
    overflow: hidden;
  }

  /* Hide desktop panels */
  #ui { display: none; }
  #analyticsBox { display: none; }

  /* Show mobile chrome */
  #mobileStats { display: flex; }
  #mobileNav { display: flex; }
  #mobileDrawer { display: block; }

  /* Canvas fills space between top bar and bottom nav */
  #game {
    position: fixed;
    top: 44px;
    left: 0;
    right: 0;
    bottom: 52px;
    width: 100% !important;
    touch-action: none;
  }

  /* Drawer content */
  #mobileDrawer .stat { font-size: 15px; margin: 5px 0; }
  #mobileDrawer button { font-size: 15px; padding: 10px; }
  #mobileDrawer .infoBtn { display: none; } /* hide info buttons on mobile */
  #mobileDrawer .small { font-size: 13px; }

  /* Prevent tooltip on mobile (we use tap modals instead) */
  #tooltip { display: none !important; }

  /* Bigger touch targets for shop controls */
  #mobileDrawer .row button { min-height: 44px; }
}
</style>
</head>
<body>

<!-- LEFT PANEL -->
<div id="ui">

  <div class="stat">üí∞ Money: <span id="money"></span></div>
  <div class="stat">
    ‚≠ê Reputation: <span id="rep"></span>
    <span id="repTier" style="font-weight:bold; margin-left:5px;"></span>
  </div>
  <div class="stat">üë• Visitors: <span id="visitors"></span></div>
  <div class="stat">üíº Wave Salary: <span id="salaryDisplay"></span></div>

  <div id="threatIntelPanel" style="display:none; margin-top:6px; padding:6px 8px; background:#1a1a1a; border-radius:4px; font-size:11px;"></div>
  <div id="salaryForecastPanel" style="margin-top:4px; font-size:11px; color:#888;"></div>

  <hr>

  <div>Wave: <span id="waveNum">1</span></div>
  <div>Phase: <span id="phaseDisplay">Planning</span></div>
  <button onclick="startWave()">Start Wave</button>
  <button onclick="resetGame()" style="margin-top:10px;">Reset Game</button>

  <hr>

  <div class="row">
    <b>Global Surveillance</b>
    <button class="infoBtn"
      onmouseenter="showTooltip(event,'cctv')"
      onmousemove="moveTooltip(event)"
      onmouseleave="hideTooltip()"
      onclick="showInfoPanel('cctv')"
      title="More info"
    >‚Ñπ</button>
  </div>

  <div id="cctvPanel"></div>

  <div id="shopUnlockPanel" style="margin-top:10px; display:none;"></div>

  <div class="row" style="margin-top:10px;">
    <button onclick="addGuard()">Place Guard (¬£150)</button>
    <button class="infoBtn"
      onmouseenter="showTooltip(event,'guards')"
      onmousemove="moveTooltip(event)"
      onmouseleave="hideTooltip()"
      onclick="showInfoPanel('guards')"
      title="More info"
    >‚Ñπ</button>
  </div>

  <div class="row" style="margin-top:10px;">
    <button onclick="addCamera()" id="placeCameraBtn">Place Camera (¬£50) [0/4]</button>
    <button class="infoBtn"
      onmouseenter="showTooltip(event,'cameras')"
      onmousemove="moveTooltip(event)"
      onmouseleave="hideTooltip()"
      onclick="showInfoPanel('cameras')"
      title="More info"
    >‚Ñπ</button>
  </div>

  <div id="shopControls"></div>

</div>

<!-- CENTER CANVAS -->
<canvas id="game"></canvas>

<!-- RIGHT PANEL -->
<div id="analyticsBox">
  <h3 id="rightTitle">Wave Overview</h3>

  <div class="rightTabs">
    <button onclick="setRightMode('wave')">Wave Overview</button>
    <button onclick="setRightMode('info')">Security Info</button>
    <button onclick="setRightMode('rules')">Rules</button>
  </div>

  <div id="analyticsPanel" class="small">Start a wave to see results.</div>
  <div id="infoPanel" class="small" style="display:none;">
    Click any ‚Ñπ button to see details here.
  </div>
  <div id="rulesPanel" class="small" style="display:none;">
    <!-- Rules content will go here -->
  </div>
</div>

<!-- MOBILE STATS BAR (top) -->
<div id="mobileStats">
  <div class="mStat">üí∞ <span id="mMoney"></span></div>
  <div class="mStat">‚≠ê <span id="mRep"></span></div>
  <div class="mStat">üë• <span id="mVisitors"></span></div>
  <div style="flex:1"></div>
  <button id="mStartWave" onclick="startWave()">‚ñ∂ START</button>
</div>

<!-- MOBILE DRAWER (slides up) -->
<div id="mobileDrawer" class="hidden">
  <div id="mobileDrawerContent"></div>
</div>

<!-- MOBILE BOTTOM NAV -->
<div id="mobileNav">
  <button id="mNavCanvas" class="active" onclick="setMobileTab('canvas')">üó∫ MAP</button>
  <button id="mNavControls" onclick="setMobileTab('controls')">üéõ CONTROLS</button>
  <button id="mNavAnalytics" onclick="setMobileTab('analytics')">üìä STATS</button>
</div>



<!-- floating tooltip -->
<div id="tooltip"></div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function isMobile(){ return window.innerWidth <= 768; }

function resizeCanvas(){
  if(isMobile()){
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight - 44 - 52; // minus top bar and bottom nav
  } else {
    canvas.width = window.innerWidth - 320 - 260;
    canvas.height = window.innerHeight;
  }
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

/* ======================
   GAME STATE
====================== */
let money = 1500;
let reputation = 25;
let placingGuard = false;
let placingCamera = false;
let cameraPlacementStep = 0; // 0 = not placing, 1 = placed waiting for direction
let tempCamera = null; // Temporary camera while setting direction
let selectedShopIndex = null;
let hoveredShopIndex = null;


let gamePhase = "planning";
let waveTimer = 0;

// === ORGANISED CRIME STATE ===
// Flash Mob
let flashMobPending = false;       // Mob queued this wave
let flashMobTimer = 0;             // Countdown before mob arrives
let flashMobWarningShown = false;  // Warning message shown
let flashMobKnowledge = 0;         // 0-10: increases each wave they appear

// Professional Crew
let crewScoutActive = false;       // Scout is in the mall
let crewScoutId = null;            // Reference to scout visitor
let crewPending = false;           // Crew waiting to spawn
let crewTimer = 0;                 // Countdown after scout finishes
let crewWarningShown = false;      // Warning shown this wave
let crewScoutCaught = false;       // Scout was caught by camera
let crewKnowledge = 0;             // 0-10: increases each wave crew appears
let waveLength = 30;
let waveNumber = 1;

// FPS tracking
let fps = 0;
let frameCount = 0;
let fpsTimer = 0;

let cctvLevel = 0;
const maxLevel = 5;

// Camera limits
function getMaxCameras(){
  // Levels 1-4: +2 cameras each. Level 5: +4 cameras (bulk monitoring expansion)
  if(cctvLevel <= 4) return 4 + (cctvLevel * 2); // 4, 6, 8, 10, 12
  return 16; // Level 5: 16 cameras
}

const path = [
  {x:200,y:200},  // Entrance
  {x:900,y:200},
  {x:900,y:700},
  {x:200,y:700},
  {x:200,y:200}   // Exit (back to entrance)
];

// üîπ Wave analytics (persistent reference)
let waveStats = {
  mallRevenue: 0,
  theftLoss: 0,
  thefts: 0,
  offenders: new Set(),
  salaryPaid: 0,

  // NEW: experiment visibility
  visitorTypes: { ordinary: 0, opportunist: 0, determined: 0, bigspender: 0, specialist: 0 },
  theftsByType:  { ordinary: 0, opportunist: 0, determined: 0, specialist: 0 },
  
  // NEW: shop-level theft tracking
  shopThefts: {},  // { shopIndex: count }
  shopLosses: {},  // { shopIndex: lossAmount }
  
  // Reputation tracking
  repStart: 0,       // Mall rep at wave start
  shopRepStart: {}   // { shopIndex: repAtStart }
};

/* ======================
   INFO TEXT (SECURITY HELP)
====================== */
const infoText = {
  cctv: `
    <b>CCTV Infrastructure</b><br>
    Enhances your camera network.<br><br>
    <span class="muted">
    ‚Ä¢ Does NOT provide global surveillance<br>
    ‚Ä¢ Boosts ALL placed cameras by +2 risk per level<br>
    ‚Ä¢ Place cameras first, then upgrade CCTV<br>
    ‚Ä¢ Level 4: +8 to all camera detections<br>
    ‚Ä¢ Cost effective when you have many cameras
    </span>
  `,
  guards: `
    <b>Security Guards</b><br>
    Strong local deterrent (+20 R in radius).<br><br>
    <span class="muted">
    ‚Ä¢ Powerful 130px coverage area<br>
    ‚Ä¢ Reduces repeat offending pressure<br>
    ‚Ä¢ Costs ¬£1/second during waves (¬£30/wave)<br>
    ‚Ä¢ More effective than cameras but expensive
    </span>
  `,
  cameras: `
    <b>CCTV Cameras</b><br>
    Mark visitors when they cross camera cone.<br><br>
    <span class="muted">
    ‚Ä¢ ¬£50 one-time cost (no ongoing salary)<br>
    ‚Ä¢ Mark when visitor crosses cone (not continuous AoE)<br>
    ‚Ä¢ 1st camera: +8 risk for 10 seconds<br>
    ‚Ä¢ 2nd camera: +12 risk<br>
    ‚Ä¢ 3rd camera: +15 risk<br>
    ‚Ä¢ 4th+ camera: +18 risk (max)<br>
    ‚Ä¢ CCTV upgrades add +2 risk per level<br>
    ‚Ä¢ Place at chokepoints for maximum detections
    </span>
  `,
  profit: `
    <b>Profit-Focused Model</b><br>
    Maximizes revenue through efficiency and automation.<br><br>
    <span class="muted">
    ‚Ä¢ Increases revenue per customer purchase<br>
    ‚Ä¢ Often reduces staffing costs<br>
    ‚Ä¢ May increase opportunity for theft<br>
    ‚Ä¢ Trade-off: Higher profit but potentially more vulnerable
    </span>
  `,
  security: `
    <b>Security-Focused Model</b><br>
    Reduces theft through protective measures.<br><br>
    <span class="muted">
    ‚Ä¢ Choose between Target Hardening or Guardianship<br>
    ‚Ä¢ Reduces theft losses<br>
    ‚Ä¢ Usually increases staffing costs<br>
    ‚Ä¢ Trade-off: Lower profit but better protection
    </span>
  `,
  targetHardening: `
    <b>Target Hardening</b><br>
    Physical barriers that reduce <b>opportunity</b> (O).<br><br>
    <span class="muted">
    ‚Ä¢ Tags, locks, controlled access<br>
    ‚Ä¢ Makes items physically harder to steal<br>
    ‚Ä¢ Strong vs opportunist theft<br>
    ‚Ä¢ May increase staff costs slightly
    </span>
  `,
  guardianship: `
    <b>Guardianship</b><br>
    Staff presence that reduces <b>motivation</b> (M).<br><br>
    <span class="muted">
    ‚Ä¢ Engagement, supervision, awareness<br>
    ‚Ä¢ Social pressure deters casual theft<br>
    ‚Ä¢ Requires ongoing staffing investment<br>
    ‚Ä¢ Creates informal surveillance through human presence
    </span>
  `,
  
  // Store-specific profit explanations
  Electronics_profit: `
    <b>Electronics Profit Strategy</b><br>
    Automation and self-service to boost efficiency.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Self-Checkout: Faster transactions<br>
    ‚Ä¢ Warranty Upsell: Higher revenue per sale<br>
    ‚Ä¢ Automated Retail: Minimal staff required<br><br>
    <b>Trade-off:</b> Less staff presence means more theft opportunity
    </span>
  `,
  
  Jewellery_profit: `
    <b>Jewellery Profit Strategy</b><br>
    Premium experience and luxury service.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Premium Display: Better presentation<br>
    ‚Ä¢ Luxury Experience: High-end atmosphere<br>
    ‚Ä¢ VIP Concierge: Personalized service<br><br>
    <b>Trade-off:</b> Luxury displays may tempt determined thieves
    </span>
  `,
  
  Clothing_profit: `
    <b>Clothing Profit Strategy</b><br>
    Fast fashion and quick turnover model.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Self-Service Design: Browse freely<br>
    ‚Ä¢ Fast Fashion: High volume, low touch<br>
    ‚Ä¢ Express Checkout: Rapid purchases<br><br>
    <b>Trade-off:</b> Open access increases theft opportunity
    </span>
  `,
  
  FoodCourt_profit: `
    <b>Food Court Profit Strategy</b><br>
    Technology-driven ordering systems.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Self-Order Kiosks: Reduce wait times<br>
    ‚Ä¢ Mobile Ordering: Order from anywhere<br>
    ‚Ä¢ Full Automation: Minimal staff<br><br>
    <b>Trade-off:</b> Less supervision creates opportunities
    </span>
  `,
  
  // Store-specific target hardening
  Electronics_targetHardening: `
    <b>Electronics Target Hardening</b><br>
    Securing high-value tech products.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Security Tags: EAS tags on items<br>
    ‚Ä¢ Locked Cabinets: Physical barriers<br>
    ‚Ä¢ Smart Anti-Theft: AI detection system<br><br>
    Makes expensive electronics harder to steal
    </span>
  `,
  
  Jewellery_targetHardening: `
    <b>Jewellery Target Hardening</b><br>
    Maximum security for valuable items.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Glass Cases: Visible but protected<br>
    ‚Ä¢ Locked Cases: Staff-controlled access<br>
    ‚Ä¢ Vault Storage: Maximum protection<br><br>
    Essential for high-value jewellery protection
    </span>
  `,
  
  Clothing_targetHardening: `
    <b>Clothing Target Hardening</b><br>
    Controlling access and exits.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Security Tags: Standard retail tags<br>
    ‚Ä¢ Fitting Room Control: Monitor changing areas<br>
    ‚Ä¢ Controlled Entry: Manage store access<br><br>
    Reduces walkout theft and fitting room concealment
    </span>
  `,
  
  FoodCourt_targetHardening: `
    <b>Food Court Target Hardening</b><br>
    Managing payment and service flow.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Queue Management: Organized lines<br>
    ‚Ä¢ Controlled Payment: Centralized checkout<br>
    ‚Ä¢ Cashless System: Digital-only payments<br><br>
    Reduces walkaway theft and payment evasion
    </span>
  `,
  
  // Store-specific guardianship
  Electronics_guardianship: `
    <b>Electronics Guardianship</b><br>
    Active staff engagement with customers.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Floor Staff: Available to help<br>
    ‚Ä¢ Active Engagement: Approach customers<br>
    ‚Ä¢ Loss Prevention: Dedicated security role<br><br>
    Staff presence deters theft through social pressure
    </span>
  `,
  
  Jewellery_guardianship: `
    <b>Jewellery Guardianship</b><br>
    Personalized service and attention.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Improved Lighting: Better visibility<br>
    ‚Ä¢ Professional Staff: Trained service<br>
    ‚Ä¢ Luxury Concierge: One-on-one attention<br><br>
    Constant attention makes theft nearly impossible
    </span>
  `,
  
  Clothing_guardianship: `
    <b>Clothing Guardianship</b><br>
    Customer service as theft prevention.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Floor Assistants: Roaming staff<br>
    ‚Ä¢ Customer Engagement: Helpful presence<br>
    ‚Ä¢ Premium Service: Personalized shopping<br><br>
    Friendly service reduces anonymity and theft
    </span>
  `,
  
  FoodCourt_guardianship: `
    <b>Food Court Guardianship</b><br>
    Supervision and operational oversight.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Shift Supervisor: Management presence<br>
    ‚Ä¢ Clean & Safe: Well-maintained space<br>
    ‚Ä¢ High Efficiency: Optimized operations<br><br>
    Active management creates accountability
    </span>
  `,
  
  // Pharmacy info
  Pharmacy_profit: `
    <b>Pharmacy Profit Strategy</b><br>
    Health & beauty retail expansion.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Self-Service: Browse cosmetics freely<br>
    ‚Ä¢ Health & Beauty: Premium products<br>
    ‚Ä¢ Wellness Brand: High-margin items<br><br>
    <b>Trade-off:</b> Valuable cosmetics attract theft
    </span>
  `,
  
  Pharmacy_targetHardening: `
    <b>Pharmacy Target Hardening</b><br>
    Securing medications and cosmetics.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Item Locks: Secure high-value products<br>
    ‚Ä¢ Counter Barrier: Protected prescription area<br>
    ‚Ä¢ Cosmetics Cabinet: Locked premium items<br><br>
    Protects expensive health & beauty products
    </span>
  `,
  
  Pharmacy_guardianship: `
    <b>Pharmacy Guardianship</b><br>
    Professional healthcare staff presence.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Pharmacy Assistant: Extra staff<br>
    ‚Ä¢ Floor Presence: Active monitoring<br>
    ‚Ä¢ Health Advisor Team: Full coverage<br><br>
    Healthcare professionals provide natural surveillance
    </span>
  `,
  
  // Supermarket info
  Supermarket_profit: `
    <b>Supermarket Profit Strategy</b><br>
    Technology-driven efficiency model.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Self-Checkout: Fewer cashiers needed<br>
    ‚Ä¢ Loyalty Cards: Data-driven sales<br>
    ‚Ä¢ Scan & Go: Fully automated shopping<br><br>
    <b>Trade-off:</b> Less staff = more concealment opportunities
    </span>
  `,
  
  Supermarket_targetHardening: `
    <b>Supermarket Target Hardening</b><br>
    Exit control and sensor systems.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Exit Gates: Electronic barriers<br>
    ‚Ä¢ Bagging Sensors: Monitor checkout<br>
    ‚Ä¢ Smart Carts: Track items in cart<br><br>
    Large space requires systematic approach
    </span>
  `,
  
  Supermarket_guardianship: `
    <b>Supermarket Guardianship</b><br>
    Roaming staff and security presence.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Aisle Monitors: Staff throughout store<br>
    ‚Ä¢ Roaming Security: Mobile surveillance<br>
    ‚Ä¢ Loss Prevention: Dedicated team<br><br>
    Large footprint needs active patrols
    </span>
  `,
  
  // Toy Shop info
  ToyShop_profit: `
    <b>Toy Shop Profit Strategy</b><br>
    Interactive experience and engagement.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Demo Stations: Try before you buy<br>
    ‚Ä¢ Seasonal Merchandising: Holiday displays<br>
    ‚Ä¢ Experience Store: Play areas and events<br><br>
    <b>Trade-off:</b> Interactive displays increase concealment
    </span>
  `,
  
  ToyShop_targetHardening: `
    <b>Toy Shop Target Hardening</b><br>
    Securing small, high-value items.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Packaging Security: Blister packs, boxes<br>
    ‚Ä¢ Item Cabinets: Lock expensive toys<br>
    ‚Ä¢ Smart Sensors: Detect shelf removal<br><br>
    Small toys are easy to pocket - need protection
    </span>
  `,
  
  ToyShop_guardianship: `
    <b>Toy Shop Guardianship</b><br>
    Family-friendly staff engagement.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Play Area Supervision: Monitor kids<br>
    ‚Ä¢ Sales Assistance: Helpful presence<br>
    ‚Ä¢ Family Service: Personalized attention<br><br>
    Parents and staff create natural surveillance
    </span>
  `,
  
  // Tech Accessories info
  TechAccessories_profit: `
    <b>Tech Accessories Profit Strategy</b><br>
    High-margin accessories and impulse buys.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Display Fixtures: Eye-catching presentation<br>
    ‚Ä¢ Bundle Deals: Cross-selling opportunities<br>
    ‚Ä¢ Premium Accessories: High-margin items<br><br>
    <b>Trade-off:</b> Open displays increase grab-and-go theft
    </span>
  `,
  
  TechAccessories_targetHardening: `
    <b>Tech Accessories Target Hardening</b><br>
    Securing small, high-value items.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Security Packaging: Blister packs, cases<br>
    ‚Ä¢ Locked Displays: High-value items behind glass<br>
    ‚Ä¢ Spider Wraps: Cable locks on products<br><br>
    Small tech accessories are easy to pocket
    </span>
  `,
  
  TechAccessories_guardianship: `
    <b>Tech Accessories Guardianship</b><br>
    Expert staff presence and assistance.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Sales Associates: Product knowledge<br>
    ‚Ä¢ Customer Engagement: Proactive service<br>
    ‚Ä¢ Tech Specialists: Expert assistance<br><br>
    Engaged customers are less likely to steal
    </span>
  `,
  
  // Bookstore info
  Bookstore_profit: `
    <b>Bookstore Profit Strategy</b><br>
    Community space and merchandise expansion.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Coffee Bar: Caf√© integration<br>
    ‚Ä¢ Events Space: Author talks, book clubs<br>
    ‚Ä¢ Merchandise: Gift items, stationery<br><br>
    <b>Trade-off:</b> Comfortable browsing increases concealment
    </span>
  `,
  
  Bookstore_targetHardening: `
    <b>Bookstore Target Hardening</b><br>
    Protecting high-value and rare books.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Security Tags: RFID tags on books<br>
    ‚Ä¢ Exit Gates: Detection systems<br>
    ‚Ä¢ Secure Display: Rare books behind counter<br><br>
    Books are easy to conceal in bags
    </span>
  `,
  
  Bookstore_guardianship: `
    <b>Bookstore Guardianship</b><br>
    Knowledgeable staff and customer service.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Floor Staff: Roaming booksellers<br>
    ‚Ä¢ Recommendation Service: Personal assistance<br>
    ‚Ä¢ Community Presence: Regular customers<br><br>
    Friendly engagement reduces anonymity
    </span>
  `,
  
  // Luxury Goods info
  LuxuryGoods_profit: `
    <b>Luxury Goods Profit Strategy</b><br>
    Exclusive experience and premium service.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Private Appointments: VIP service<br>
    ‚Ä¢ Exclusive Collections: Limited editions<br>
    ‚Ä¢ Luxury Concierge: White-glove service<br><br>
    <b>Trade-off:</b> High-value items attract determined thieves
    </span>
  `,
  
  LuxuryGoods_targetHardening: `
    <b>Luxury Goods Target Hardening</b><br>
    Maximum security for premium items.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Vault Storage: Items locked away<br>
    ‚Ä¢ Display Cases: Reinforced glass<br>
    ‚Ä¢ Biometric Access: Restricted areas<br><br>
    Extreme value requires extreme measures
    </span>
  `,
  
  LuxuryGoods_guardianship: `
    <b>Luxury Goods Guardianship</b><br>
    Attentive service and controlled access.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Personal Shoppers: One-on-one service<br>
    ‚Ä¢ Appointment Only: Controlled access<br>
    ‚Ä¢ Security Greeter: Vetted clientele<br><br>
    Intimate service means everyone is watched
    </span>
  `,
  
  // Entertainment info
  Entertainment_profit: `
    <b>Entertainment Profit Strategy</b><br>
    Volume business and merchandise sales.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Concessions: Food and drinks<br>
    ‚Ä¢ Merchandise: Movie/gaming gear<br>
    ‚Ä¢ Premium Experiences: VIP seating<br><br>
    <b>Trade-off:</b> Dark spaces increase concealment
    </span>
  `,
  
  Entertainment_targetHardening: `
    <b>Entertainment Target Hardening</b><br>
    Securing merchandise in low-light areas.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Display Security: Locked cases<br>
    ‚Ä¢ Lighting: Illuminate dark areas<br>
    ‚Ä¢ Point of Sale: All sales at counter<br><br>
    Dark theaters provide concealment opportunities
    </span>
  `,
  
  Entertainment_guardianship: `
    <b>Entertainment Guardianship</b><br>
    Staff presence and customer interaction.<br><br>
    <span class="muted">
    <b>Upgrades:</b><br>
    ‚Ä¢ Concession Staff: Active presence<br>
    ‚Ä¢ Ushers: Theater monitoring<br>
    ‚Ä¢ Customer Service: Engagement at entry<br><br>
    Large space needs mobile staff coverage
    </span>
  `
};

/* ======================
   RIGHT PANEL MODES
====================== */
let rightMode = "wave";

function buildReputationPanel(){
  const rep = Math.round(reputation);
  
  // Determine tier
  let tier, color, spawnRate, visitorMix;
  if(reputation >= 80){
    tier = "Thriving";
    color = "#4caf50";
    spawnRate = "0.08 (Very High)";
    visitorMix = "70% ordinary, 20% opportunist, 3% determined, 7% big spenders";
  } else if(reputation >= 70){
    tier = "Excellent";
    color = "#8bc34a";
    spawnRate = "0.06 (High)";
    visitorMix = "65% ordinary, 23% opportunist, 5% determined, 7% big spenders";
  } else if(reputation >= 50){
    tier = "Stable";
    color = "#ffc107";
    spawnRate = "0.05 (Normal)";
    visitorMix = "65% ordinary, 25% opportunist, 10% determined";
  } else if(reputation >= 30){
    tier = waveNumber === 1 ? "Just Opened!" : "Unpopular";
    color = "#ff9800";
    spawnRate = "0.04 (Low)";
    visitorMix = "55% ordinary, 30% opportunist, 15% determined";
  } else if(reputation >= 15){
    tier = waveNumber === 1 ? "Just Opened!" : "Struggling";
    color = "#ff5722";
    spawnRate = "0.03 (Very Low)";
    visitorMix = "48% ordinary, 33% opportunist, 19% determined";
  } else {
    tier = waveNumber === 1 ? "Just Opened!" : "Crisis";
    color = "#f44336";
    spawnRate = "0.03 (Very Low)";
    visitorMix = "42% ordinary, 35% opportunist, 23% determined";
  }
  
  // Wave difficulty
  const waveDifficulty = waveNumber >= 3 ? Math.min(waveNumber - 2, 10) : 0;
  const difficultyText = waveDifficulty > 0 ? 
    `Wave ${waveNumber}: -${waveDifficulty}% ordinary, +${Math.round(waveDifficulty * 0.6)}% opportunist, +${Math.round(waveDifficulty * 0.4)}% determined` : 
    "No wave difficulty modifier yet";
  
  document.getElementById("reputationPanel").innerHTML = `
    <b>Current Reputation: ${rep}</b><br>
    <span style="color:${color}; font-weight:bold;">${tier}</span><br><br>
    
    <b>Effects:</b><br>
    <div class="small">
    ‚Ä¢ Visitor Volume: ${spawnRate}<br>
    ‚Ä¢ Base Mix: ${visitorMix}<br>
    ‚Ä¢ ${difficultyText}<br><br>
    </div>
    
    <b>Thresholds:</b><br>
    <div class="small">
    ‚Ä¢ 80+: Thriving (big spenders appear)<br>
    ‚Ä¢ 70+: Excellent (big spenders unlock)<br>
    ‚Ä¢ 50-69: Stable (balanced mix)<br>
    ‚Ä¢ 20-49: Unpopular (more criminals)<br>
    ‚Ä¢ 0-19: Crisis (death spiral)<br><br>
    </div>
    
    <b>How to Improve:</b><br>
    <div class="small">
    ‚Ä¢ +1 per purchase<br>
    ‚Ä¢ -1.5 per theft<br>
    ‚Ä¢ Prevent thefts to grow reputation<br>
    </div>
  `;
}

function buildRulesPanel(){
  document.getElementById("rulesPanel").innerHTML = `
    <b>üéØ Game Objective</b><br>
    Manage mall security to maximize profit while maintaining reputation. Balance security costs against theft losses.<br><br>
    
    <b>üí∞ Economy</b><br>
    ‚Ä¢ Start with ¬£2000<br>
    ‚Ä¢ Earn 35% from each purchase<br>
    ‚Ä¢ Lose 60% of shop value per theft<br>
    ‚Ä¢ Guards cost ¬£1/second during waves<br>
    ‚Ä¢ Cameras are one-time ¬£50 cost<br><br>
    
    <b>‚≠ê Reputation System</b><br>
    ‚Ä¢ Start at 50 reputation<br>
    ‚Ä¢ +1 per purchase, -1.5 per theft<br>
    ‚Ä¢ High rep (70+): More customers, big spenders appear<br>
    ‚Ä¢ Low rep (0-20): Fewer customers, more criminals<br>
    ‚Ä¢ Reputation drives visitor mix and volume<br><br>
    
    <b>üë• Visitor Types</b><br>
    ‚Ä¢ üü¢ Ordinary (green): Low theft risk, reliable shoppers<br>
    ‚Ä¢ üü° Opportunist (yellow): Steal if opportunity arises<br>
    ‚Ä¢ üî¥ Determined (red): High motivation to steal<br>
    ‚Ä¢ ‚ú® Big Spender (large green + gold glow): Multiple purchases, no theft<br><br>
    
    <b>üè™ Shop Strategies</b><br>
    <b>Profit Model:</b> Maximize revenue but increase theft opportunity<br>
    <b>Security Model:</b> Choose one or both:<br>
    ‚Ä¢ Target Hardening (üîí): Physical barriers reduce opportunity<br>
    ‚Ä¢ Guardianship (üëÅ): Staff presence reduces motivation<br><br>
    
    <b>üõ°Ô∏è Security Tools</b><br>
    ‚Ä¢ <b>CCTV Infrastructure:</b> ¬£120-720, enhances ALL cameras (+2 risk/level)<br>
      - Does NOT provide global surveillance<br>
      - Boosts placed cameras only<br>
    ‚Ä¢ <b>Guards:</b> ¬£150 + ¬£1/sec, adds +20 risk in 130px radius<br>
      - Patrol linearly along corridors or across shops<br>
      - Dark blue circle shows active patrol position<br>
    ‚Ä¢ <b>Cameras:</b> ¬£50, mark visitors when crossed<br>
      - 1st camera: +8 risk for 10s<br>
      - 2nd camera: +12 risk for 10s<br>
      - 3rd camera: +15 risk for 10s<br>
      - 4th+ camera: +18 risk (max)<br>
      - Marks stack and last 10 seconds<br>
      - Two-tap placement: position, then aim<br><br>
    
    <b>üîó Synergies</b><br>
    ‚Ä¢ <b>Camera + Target Hardening:</b> +5 bonus risk to marks<br>
    ‚Ä¢ <b>Guard + Guardianship:</b> +5 bonus risk<br>
    Combine security layers for maximum effectiveness!<br><br>
    
    <b>üé≤ Theft Mechanics</b><br>
    Theft occurs when:<br>
    theftScore = Motivation + Opportunity - Risk > 40<br>
    ‚Ä¢ Motivation: Visitor's desire to steal<br>
    ‚Ä¢ Opportunity: How easy the shop is to steal from<br>
    ‚Ä¢ Risk: Security presence (cameras, guards)<br><br>
    
    <b>üìä Wave System</b><br>
    ‚Ä¢ 30-second waves with planning phase between<br>
    ‚Ä¢ Visitors spawn in first 12 seconds<br>
    ‚Ä¢ Wave ends when timer + all visitors leave<br>
    ‚Ä¢ Previous wave stats shown during planning<br><br>
    
    <b>üí° Tips</b><br>
    ‚Ä¢ üõ°Ô∏è Shield = security prevented theft!<br>
    ‚Ä¢ Place cameras at chokepoints to mark visitors<br>
    ‚Ä¢ CCTV upgrades boost all cameras (+2/level)<br>
    ‚Ä¢ Guards patrol along corridors and across shops<br>
    ‚Ä¢ Check "Thefts by Shop" to prioritize upgrades<br>
    ‚Ä¢ Big spenders (gold glow) unlock at 70+ reputation<br>
    ‚Ä¢ Camera network + CCTV = powerful combo!
  `;
}

function setRightMode(mode){
  rightMode = mode;

  const analytics = document.getElementById("analyticsPanel");
  const info = document.getElementById("infoPanel");
  const rules = document.getElementById("rulesPanel");
  const title = document.getElementById("rightTitle");

  if(mode === "wave"){
    title.innerText = "Wave Overview";
    analytics.style.display = "block";
    info.style.display = "none";
    rules.style.display = "none";
  } else if(mode === "info"){
    title.innerText = "Security Info";
    analytics.style.display = "none";
    info.style.display = "block";
    rules.style.display = "none";
  } else if(mode === "rules"){
    title.innerText = "Game Rules";
    analytics.style.display = "none";
    info.style.display = "none";
    rules.style.display = "block";
    buildRulesPanel();
  }
}

function showInfoPanel(key, shopName){
  setRightMode("info");
  const panel = document.getElementById("infoPanel");

  // Optional: show which shop it's about
  const prefix = shopName ? `<div style="margin-bottom:6px;"><b>${shopName}</b></div>` : "";

  panel.innerHTML = `
    ${prefix}
    ${infoText[key] || "No info available."}
    <div class="muted" style="margin-top:8px;">
      Tip: Hover ‚Ñπ for a quick tooltip, click ‚Ñπ to pin the info here.
    </div>
  `;
}

/* ======================
   TOOLTIP
====================== */
const tooltip = document.getElementById("tooltip");

function showTooltip(e, key){
  tooltip.innerHTML = infoText[key] || "";
  tooltip.style.display = "block";
  moveTooltip(e);
}
function moveTooltip(e){
  const pad = 14;
  let x = e.clientX + pad;
  let y = e.clientY + pad;

  // keep on-screen
  const rect = tooltip.getBoundingClientRect();
  if(x + rect.width > window.innerWidth) x = e.clientX - rect.width - pad;
  if(y + rect.height > window.innerHeight) y = e.clientY - rect.height - pad;

  tooltip.style.left = x + "px";
  tooltip.style.top = y + "px";
}
function hideTooltip(){
  tooltip.style.display = "none";
}

/* ======================
   UPGRADE DATA
====================== */
const cctvLevels = [
  "No CCTV",
  "Visible Cameras",
  "Monitored Cameras",
  "AI Detection System",
  "Integrated Security Network"
];

/* ======================
   UNLOCKABLE SHOPS SYSTEM
====================== */

const unlockableShops = [
  {
    wave: 3,
    minRep: 60,
    cost: 300,
    id: "techaccessories",
    shop: {
      name: "Tech Accessories",
      node: "techaccessories",
      type: "TechAccessories",
      value: 55,
      baseOpportunity: 23,
      strategy: null,
      profitTier: 0,
      hardeningTier: 0,
      guardianshipTier: 0,
      revenueBonus: 0,
      salary: 0,
      rep: 25,
      theftCount: 0
    }
  },
  {
    wave: 5,
    minRep: 70,
    cost: 500,
    id: "bookstore",
    shop: {
      name: "Bookstore",
      node: "bookstore",
      type: "Bookstore",
      value: 48,
      baseOpportunity: 18,
      strategy: null,
      profitTier: 0,
      hardeningTier: 0,
      guardianshipTier: 0,
      revenueBonus: 0,
      salary: 0,
      rep: 25,
      theftCount: 0
    }
  },
  {
    wave: 7,
    minRep: 75,
    cost: 900,
    id: "luxurydistrict",
    requires: ["techaccessories", "bookstore"], // Needs BOTH first (sequential)
    multiShop: true,
    shops: [
      {
        name: "Luxury Goods",
        node: "luxurygoods",
        type: "LuxuryGoods",
        value: 95,
        baseOpportunity: 32,
        strategy: null,
        profitTier: 0,
        hardeningTier: 0,
        guardianshipTier: 0,
        revenueBonus: 0,
        salary: 0,
        rep: 25,
        theftCount: 0
      },
      {
        name: "Wine Shop",
        node: "wineshop",
        type: "WineShop",
        value: 60,
        baseOpportunity: 26,
        strategy: null,
        profitTier: 0,
        hardeningTier: 0,
        guardianshipTier: 0,
        revenueBonus: 0,
        salary: 0,
        rep: 25,
        theftCount: 0
      }
    ]
  },
  {
    wave: 10,
    minRep: 80,
    cost: 1000,
    id: "entertainmentcomplex",
    requires: ["luxurydistrict"], // Needs luxury district first (sequential)
    multiShop: true,
    shops: [
      {
        name: "Cinema",
        node: "cinema",
        type: "Cinema",
        value: 35,
        baseOpportunity: 16,
        strategy: null,
        profitTier: 0,
        hardeningTier: 0,
        guardianshipTier: 0,
        revenueBonus: 0,
        salary: 0,
        rep: 25,
        theftCount: 0
      },
      {
        name: "Bowling",
        node: "bowling",
        type: "Bowling",
        value: 30,
        baseOpportunity: 14,
        strategy: null,
        profitTier: 0,
        hardeningTier: 0,
        guardianshipTier: 0,
        revenueBonus: 0,
        salary: 0,
        rep: 25,
        theftCount: 0
      },
      {
        name: "Arcade",
        node: "arcade",
        type: "Arcade",
        value: 25,
        baseOpportunity: 12,
        strategy: null,
        profitTier: 0,
        hardeningTier: 0,
        guardianshipTier: 0,
        revenueBonus: 0,
        salary: 0,
        rep: 25,
        theftCount: 0
      },
      {
        name: "Food Court 2",
        node: "foodcourt2",
        type: "FoodCourt",
        value: 20,
        baseOpportunity: 10,
        strategy: null,
        profitTier: 0,
        hardeningTier: 0,
        guardianshipTier: 0,
        revenueBonus: 0,
        salary: 0,
        rep: 25,
        theftCount: 0
      }
    ]
  }
];

let availableShopUnlocks = []; // Shops that can be unlocked this wave
let unlockedShops = []; // Track which shops have been unlocked
let newPathUnlocked = false; // Track if NE path is unlocked

/* ======================
   MALL NODE GRAPH
====================== */

const nodes = {
  entranceMain: { 
    id:"entranceMain", 
    x:120, 
    y:450, 
    type:"transit", 
    connections:["hub"] 
  },

  entranceSide: { 
    id:"entranceSide", 
    x:1120, 
    y:450, 
    type:"transit", 
    connections:["hub"] 
  },

  hub: {
    id:"hub",
    x:600,
    y:450,
    type:"decision",
    connections:["entranceMain","entranceSide","north","toyshop","east","south","food","pharmacy","wineshop","bookstore"]
  },

  // North spoke - Electronics with Toy Shop along the path
  north: { id:"north", x:600, y:150, type:"shop", connections:["hub"] },
  toyshop: { id:"toyshop", x:600, y:280, type:"shop", connections:["hub"] },
  
  // East spoke - Clothing, with Tech Accessories along the path
  east:  { id:"east",  x:1000,y:450, type:"shop", connections:["hub","eastJunction"] },
  
  south: { id:"south", x:600, y:750, type:"shop", connections:["hub"] },
  food:  { id:"food",  x:600, y:600, type:"shop", connections:["hub"] },
  
  // West spoke - Pharmacy connects to hub, Supermarket extends from Pharmacy
  pharmacy: { id:"pharmacy", x:350, y:550, type:"shop", connections:["hub","supermarket"] },
  supermarket: { id:"supermarket", x:200, y:650, type:"shop", size:"large", connections:["pharmacy"] },
  
  // Unlockable shops
  // Wave 3: Tech Accessories on east corridor (between hub and east junction)
  techaccessories: { id:"techaccessories", x:800, y:450, type:"shop", connections:["hub","eastJunction"], unlocked: false },
  
  // East corridor junction - pathway to entertainment complex
  eastJunction: { id:"eastJunction", x:900, y:450, type:"transit", connections:["techaccessories","east","southJunction"], unlocked: true },
  
  // Wave 5: Bookstore on west main entrance corridor (between entrance and hub)
  bookstore: { id:"bookstore", x:300, y:450, type:"shop", connections:["hub"], unlocked: false },
  
  // Wave 7: Northeast LUXURY spoke - diagonal northeast (hub ‚Üí wine ‚Üí junction ‚Üí luxury)
  wineshop: { id:"wineshop", x:750, y:300, type:"shop", connections:["hub","northeastJunction"], unlocked: false },
  northeastJunction: { id:"northeastJunction", x:900, y:200, type:"transit", connections:["wineshop","luxurygoods"], unlocked: false },
  luxurygoods: { id:"luxurygoods", x:1050, y:100, type:"shop", connections:["northeastJunction"], unlocked: false },
  
  // Wave 10: South ENTERTAINMENT complex - branches from east corridor junction
  southJunction: { id:"southJunction", x:900, y:600, type:"transit", connections:["eastJunction","cinema","bowling","arcade","foodcourt2"], unlocked: false },
  cinema: { id:"cinema", x:850, y:750, type:"shop", connections:["southJunction"], unlocked: false },
  bowling: { id:"bowling", x:950, y:750, type:"shop", connections:["southJunction"], unlocked: false },
  arcade: { id:"arcade", x:850, y:850, type:"shop", connections:["southJunction"], unlocked: false },
  foodcourt2: { id:"foodcourt2", x:950, y:850, type:"shop", connections:["southJunction"], unlocked: false }
};

/* ======================
   SHOPS
====================== */
const shops = [
  {
    name:"Electronics",
    type:"Electronics",
    node:"north",
    value:70,
    baseOpportunity:25,

    strategy:null,
    
    profitTier:0,
    hardeningTier:0,
    guardianshipTier:0,

    revenueBonus:0,

    salary:0,
    rep:25,
    theftCount:0
  },
  {
    name:"Clothing",
    type:"Clothing",
    node:"east",
    value:40,
    baseOpportunity:20,

    strategy:null,
    
    profitTier:0,
    hardeningTier:0,
    guardianshipTier:0,

    revenueBonus:0,

    salary:0,
    rep:25,
    theftCount:0
  },
  {
    name:"Jewellery",
    type:"Jewellery",
    node:"south",
    value:100,
    baseOpportunity:35,

    strategy:null,
    
    profitTier:0,
    hardeningTier:0,
    guardianshipTier:0,

    revenueBonus:0,

    salary:0,
    rep:25,
    theftCount:0
  },
  {
    name:"Food Court",
    type:"FoodCourt",
    node:"food",
    value:20,
    baseOpportunity:10,

    strategy:null,
    
    profitTier:0,
    hardeningTier:0,
    guardianshipTier:0,

    revenueBonus:0,

    salary:0,
    rep:25,
    theftCount:0
  },
  {
    name:"Supermarket",
    type:"Supermarket",
    node:"supermarket",
    value:35,
    baseOpportunity:22,

    strategy:null,
    
    profitTier:0,
    hardeningTier:0,
    guardianshipTier:0,

    revenueBonus:0,

    salary:0,
    rep:25,
    theftCount:0
  },
  {
    name:"Pharmacy",
    type:"Pharmacy",
    node:"pharmacy",
    value:55,
    baseOpportunity:28,

    strategy:null,
    
    profitTier:0,
    hardeningTier:0,
    guardianshipTier:0,

    revenueBonus:0,

    salary:0,
    rep:25,
    theftCount:0
  },
  {
    name:"Toy Shop",
    type:"ToyShop",
    node:"toyshop",
    value:50,
    baseOpportunity:24,

    strategy:null,
    
    profitTier:0,
    hardeningTier:0,
    guardianshipTier:0,

    revenueBonus:0,

    salary:0,
    rep:25,
    theftCount:0
  }
];

// ======================
// SHOP LOOKUP MAP (nodeId ‚Üí shop)
// ======================
const shopByNode = {};

shops.forEach(shop => {
  shopByNode[shop.node] = shop;
});
const guards = [];
const cameras = [];
let visitors = [];

// Visual effects
let floatingTexts = [];
let particles = [];
let preventionIndicators = []; // Show when security prevents theft

/* ======================
   COST CALC
====================== */
function upgradeCost(base, level){
  return base * (level + 1);
}

/* ======================
   SALARY HELPERS
====================== */
function getGuardSalaryPerSec(){
  return guards.length * 1;
}

function getShopSalaryPerSec(){
  return shops.reduce((sum, s) => sum + (s.salary || 0), 0);
}

function getCCTVSalaryPerSec(){
  if(cctvLevel === 0) return 0;
  if(cctvLevel <= 4) return cctvLevel * 0.5;
  return 3.5; // Level 5: ¬£3.5/sec
}

// Reputation salary multiplier - prestige demands better security pay
// Rep 0-74:   √ó1.0 (no change)
// Rep 75-124: √ó1.0 ‚Üí √ó1.2
// Rep 125-174: √ó1.2 ‚Üí √ó1.4
// Capped at √ó1.4 - meaningful but not game-defining
function getRepSalaryMultiplier(){
  if(reputation < 75) return 1.0;
  const brackets = Math.floor((reputation - 75) / 50);
  const remainder = (reputation - 75) % 50;
  return Math.min(1.4, 1.0 + (brackets * 0.2) + (remainder / 50) * 0.2);
}

function getTotalSalaryPerSec(){
  const shopBase = getShopSalaryPerSec();                    // Flat - your decision
  const securityBase = getGuardSalaryPerSec() + getCCTVSalaryPerSec(); // Scales with rep
  return shopBase + (securityBase * getRepSalaryMultiplier());
}

/* ======================
   UI BUILDERS
====================== */
function buildSelectedShopUI(){

  const container = document.getElementById("shopControls");
  container.innerHTML = "";

  if(selectedShopIndex === null){
    container.innerHTML = "<div class='small'>Click a shop to manage it.</div>";
    return;
  }

  const shop = shops[selectedShopIndex];

  // Build UI based on strategy choice
  let strategySection = "";
  
  if(!shop.strategy){
    // No strategy chosen yet
    strategySection = `
      <hr>
      <div class="small"><b>Choose Store Strategy:</b></div>
      
      <div class="row">
        <button onclick="previewProfitModel(${selectedShopIndex})" style="flex:1;">
          Profit-Focused Model
        </button>
        <button class="infoBtn"
          onmouseenter="showTooltip(event,'profit')"
          onmousemove="moveTooltip(event)"
          onmouseleave="hideTooltip()"
          onclick="showInfoPanel('profit','${shop.name}')"
        >‚Ñπ</button>
      </div>
      
      <div class="row">
        <button onclick="previewSecurityModel(${selectedShopIndex})" style="flex:1;">
          Security-Focused Model
        </button>
        <button class="infoBtn"
          onmouseenter="showTooltip(event,'security')"
          onmousemove="moveTooltip(event)"
          onmouseleave="hideTooltip()"
          onclick="showInfoPanel('security','${shop.name}')"
        >‚Ñπ</button>
      </div>
    `;
  } else if(shop.strategy === "profit_preview"){
    // Preview profit model - confirm or go back
    strategySection = `
      <hr>
      <div class="row">
        <div class="small"><b>Profit Model Preview</b></div>
        <button class="infoBtn"
          onmouseenter="showTooltip(event,'${shop.type}_profit')"
          onmousemove="moveTooltip(event)"
          onmouseleave="hideTooltip()"
          onclick="showInfoPanel('${shop.type}_profit','${shop.name}')"
        >‚Ñπ</button>
      </div>
      <div class="small" style="margin-top:8px;">
        Focus on maximizing revenue through efficiency and automation. This may increase theft opportunities.
      </div>
      
      <button onclick="confirmProfitModel(${selectedShopIndex})" style="background:#2e7d32;">
        ‚úì Confirm Profit Model
      </button>
      <button onclick="cancelStrategy(${selectedShopIndex})" style="background:#666;">
        ‚Üê Go Back
      </button>
    `;
  } else if(shop.strategy === "security_preview"){
    // Preview security model - confirm or go back
    strategySection = `
      <hr>
      <div class="row">
        <div class="small"><b>Security Model Preview</b></div>
        <button class="infoBtn"
          onmouseenter="showTooltip(event,'security')"
          onmousemove="moveTooltip(event)"
          onmouseleave="hideTooltip()"
          onclick="showInfoPanel('security','${shop.name}')"
        >‚Ñπ</button>
      </div>
      <div class="small" style="margin-top:8px;">
        Focus on reducing theft through Target Hardening and Guardianship. Both branches available to upgrade independently.
      </div>
      
      <button onclick="confirmSecurityModel(${selectedShopIndex})" style="background:#2e7d32;">
        ‚úì Confirm Security Model
      </button>
      <button onclick="cancelStrategy(${selectedShopIndex})" style="background:#666;">
        ‚Üê Go Back
      </button>
    `;
  } else if(shop.strategy === "profit"){
    // Profit model - show profit upgrades
    const track = storeUpgradeData[shop.type].profit;
    const current = track[shop.profitTier];
    const next = track[shop.profitTier + 1];
    
    // Check if profit is maxed (can unlock security)
    const profitMaxed = shop.profitTier >= track.length - 1;
    const securityUnlocked = shop.securityBranchUnlocked || false;
    
    strategySection = `
      <hr>
      <div class="row">
        <div class="small"><b>Profit Model</b></div>
        <button class="infoBtn"
          onmouseenter="showTooltip(event,'${shop.type}_profit')"
          onmousemove="moveTooltip(event)"
          onmouseleave="hideTooltip()"
          onclick="showInfoPanel('${shop.type}_profit','${shop.name}')"
        >‚Ñπ</button>
      </div>
      <div class="small">Current: ${current.name}</div>
      ${next ? `
        <div class="small">Next: ${next.name}</div>
        <button onclick="upgradeProfit(${selectedShopIndex})">
          Upgrade (¬£${next.cost})
        </button>
      ` : `
        <div class="small">Max Level</div>
        ${!securityUnlocked ? `
          <hr style="margin:8px 0;">
          <div class="small"><b>üîì Unlock Security Branch?</b></div>
          <div class="small" style="margin-top:4px;">
            Add Target Hardening to your automated store with sensors and smart locks.
          </div>
          <button onclick="unlockSecurityBranch(${selectedShopIndex})" style="background:#1976d2; margin-top:8px;">
            Unlock Target Hardening (¬£500)
          </button>
        ` : ''}
      `}
      
      ${securityUnlocked ? `
        <hr style="margin:8px 0;">
        <div class="row">
          <div class="small"><b>Target Hardening</b></div>
          <button class="infoBtn"
            onmouseenter="showTooltip(event,'${shop.type}_targetHardening')"
            onmousemove="moveTooltip(event)"
            onmouseleave="hideTooltip()"
            onclick="showInfoPanel('${shop.type}_targetHardening','${shop.name}')"
          >‚Ñπ</button>
        </div>
        <div class="small">Current: ${shop.hardeningTier > 0 ? storeUpgradeData[shop.type].security.targetHardening[shop.hardeningTier].name : 'None'}</div>
        ${shop.hardeningTier < 3 ? `
          <div class="small">Next: ${storeUpgradeData[shop.type].security.targetHardening[(shop.hardeningTier || 0) + 1].name}</div>
          <button onclick="upgradeTargetHardening(${selectedShopIndex})">
            Upgrade (¬£${storeUpgradeData[shop.type].security.targetHardening[(shop.hardeningTier || 0) + 1].cost})
          </button>
        ` : `<div class="small">Max Level</div>`}
      ` : ''}
    `;
  } else if(shop.strategy === "security"){
    // Security model - show both branches
    const hardeningTrack = storeUpgradeData[shop.type].security.targetHardening;
    const guardianTrack = storeUpgradeData[shop.type].security.guardianship;
    
    const currentHardening = hardeningTrack[shop.hardeningTier || 0];
    const nextHardening = hardeningTrack[(shop.hardeningTier || 0) + 1];
    
    const currentGuardian = guardianTrack[shop.guardianshipTier || 0];
    const nextGuardian = guardianTrack[(shop.guardianshipTier || 0) + 1];
    
    // Check if both security branches maxed (can unlock profit)
    const hardeningMaxed = (shop.hardeningTier || 0) >= hardeningTrack.length - 1;
    const guardianshipMaxed = (shop.guardianshipTier || 0) >= guardianTrack.length - 1;
    const bothMaxed = hardeningMaxed && guardianshipMaxed;
    const profitUnlocked = shop.profitBranchUnlocked || false;
    
    strategySection = `
      <hr>
      <div class="small"><b>Security Model</b></div>
      
      <hr style="margin:8px 0;">
      
      <!-- TARGET HARDENING -->
      <div class="row">
        <div class="small"><b>Target Hardening</b></div>
        <button class="infoBtn"
          onmouseenter="showTooltip(event,'${shop.type}_targetHardening')"
          onmousemove="moveTooltip(event)"
          onmouseleave="hideTooltip()"
          onclick="showInfoPanel('${shop.type}_targetHardening','${shop.name}')"
        >‚Ñπ</button>
      </div>
      <div class="small">Current: ${currentHardening.name}</div>
      ${nextHardening ? `
        <div class="small">Next: ${nextHardening.name}</div>
        <button onclick="upgradeTargetHardening(${selectedShopIndex})">
          Upgrade (¬£${nextHardening.cost})
        </button>
      ` : `<div class="small">Max Level</div>`}
      
      <hr style="margin:8px 0;">
      
      <!-- GUARDIANSHIP -->
      <div class="row">
        <div class="small"><b>Guardianship</b></div>
        <button class="infoBtn"
          onmouseenter="showTooltip(event,'${shop.type}_guardianship')"
          onmousemove="moveTooltip(event)"
          onmouseleave="hideTooltip()"
          onclick="showInfoPanel('${shop.type}_guardianship','${shop.name}')"
        >‚Ñπ</button>
      </div>
      <div class="small">Current: ${currentGuardian.name}</div>
      ${nextGuardian ? `
        <div class="small">Next: ${nextGuardian.name}</div>
        <button onclick="upgradeGuardianship(${selectedShopIndex})">
          Upgrade (¬£${nextGuardian.cost})
        </button>
      ` : `<div class="small">Max Level</div>`}
      
      ${bothMaxed && !profitUnlocked ? `
        <hr style="margin:8px 0;">
        <div class="small"><b>üîì Unlock Profit Branch?</b></div>
        <div class="small" style="margin-top:4px;">
          Add premium service model - personalized attention and exclusive experiences.
        </div>
        <button onclick="unlockProfitBranch(${selectedShopIndex})" style="background:#2e7d32; margin-top:8px;">
          Unlock Premium Service (¬£500)
        </button>
      ` : ''}
      
      ${profitUnlocked ? `
        <hr style="margin:8px 0;">
        <div class="row">
          <div class="small"><b>Premium Service</b></div>
          <button class="infoBtn"
            onmouseenter="showTooltip(event,'${shop.type}_profit')"
            onmousemove="moveTooltip(event)"
            onmouseleave="hideTooltip()"
            onclick="showInfoPanel('${shop.type}_profit','${shop.name}')"
          >‚Ñπ</button>
        </div>
        <div class="small">Current: ${shop.profitTier > 0 ? storeUpgradeData[shop.type].profit[shop.profitTier].name : 'None'}</div>
        ${shop.profitTier < 3 ? `
          <div class="small">Next: ${storeUpgradeData[shop.type].profit[(shop.profitTier || 0) + 1].name}</div>
          <button onclick="upgradeProfit(${selectedShopIndex})">
            Upgrade (¬£${storeUpgradeData[shop.type].profit[(shop.profitTier || 0) + 1].cost})
          </button>
        ` : `<div class="small">Max Level</div>`}
      ` : ''}
    `;
  }

  container.innerHTML = `
    <hr>
    <h4>${shop.name}</h4>

    <div class="small">
      Reputation: ${Math.round(shop.rep)}
    </div>

    ${strategySection}

    <hr>

    <div class="small">
      Staff Cost: ¬£${shop.salary.toFixed(1)} / sec
    </div>
  `;
}


function buildCCTVUI(){
  const panel = document.getElementById("cctvPanel");
  const cost = cctvLevel < maxLevel ?
    upgradeCost(120, cctvLevel) : null;

  const levelDescriptions = [
    "No camera network enhancement",
    "+2 risk to all camera marks",
    "+4 risk to all camera marks", 
    "+6 risk to all camera marks",
    "+8 risk to all camera marks",
    "+8 risk to all camera marks, +4 camera capacity (monitoring team required)"
  ];
  
  const monitoringSalary = getCCTVSalaryPerSec();
  const camerasUsed = cameras.length;
  const camerasMax = getMaxCameras();
  const nextLevelCameras = cctvLevel < maxLevel ? (cctvLevel < 4 ? getMaxCameras() + 2 : 16) : null;

  panel.innerHTML = `
    <div class="small">
      <b>CCTV Infrastructure</b><br>
      Enhances all placed cameras<br>
      <b>Cameras:</b> ${camerasUsed} / ${camerasMax}<br>
      ${monitoringSalary > 0 ? `<b>Monitoring cost:</b> ¬£${monitoringSalary.toFixed(1)}/sec<br>` : ''}
      <br>
      Level ${cctvLevel}: ${levelDescriptions[cctvLevel]}
    </div>
    ${cctvLevel < maxLevel ?
      `<button onclick="upgradeCCTV()">Upgrade CCTV (¬£${cost}) ‚Üí ${nextLevelCameras} cameras</button>`
      : "<div class='small'>Max Level</div>"}
  `;
}
/* ======================
   STORE UPGRADE LIBRARY
====================== */

const storeUpgradeData = {

  Electronics: {

    profit: [
      { name:"Standard Checkout", revenueDelta:0, oppDelta:0, salaryDelta:0, cost:0 },
      { name:"Self-Checkout Machines", revenueDelta:5, oppDelta:5, salaryDelta:-0.4, cost:200 },
      { name:"Extended Warranty Upsell", revenueDelta:10, oppDelta:8, salaryDelta:-0.6, cost:350 },
      { name:"Automated Retail Model", revenueDelta:18, oppDelta:12, salaryDelta:-1.0, cost:600 }
    ],

    security: {

      targetHardening: [
        { name:"Open Display Tables", oppDelta:0, salaryDelta:0, cost:0 },
        { name:"Security Tags", oppDelta:-5, salaryDelta:0, cost:120 },
        { name:"Locked Cabinets", oppDelta:-12, salaryDelta:0.4, cost:250 },
        { name:"Smart Anti-Theft System", oppDelta:-20, salaryDelta:0.8, cost:450 }
      ],

      guardianship: [
        { name:"Minimal Supervision", motDelta:0, salaryDelta:0, cost:0 },
        { name:"Floor Staff Presence", motDelta:-3, salaryDelta:0.4, cost:150 },
        { name:"Active Engagement Model", motDelta:-7, salaryDelta:0.8, cost:300 },
        { name:"Dedicated Loss Prevention", motDelta:-12, salaryDelta:1.2, cost:550 }
      ]
    }
  },

  Jewellery: {

    profit: [
      { name:"Standard Service", revenueDelta:0, oppDelta:0, salaryDelta:0, cost:0 },
      { name:"Premium Display", revenueDelta:8, oppDelta:6, salaryDelta:0.3, cost:300 },
      { name:"Luxury Experience", revenueDelta:15, oppDelta:10, salaryDelta:0.5, cost:550 },
      { name:"VIP Concierge", revenueDelta:25, oppDelta:15, salaryDelta:0.8, cost:900 }
    ],

    security: {

      targetHardening: [
        { name:"Open Counter", oppDelta:0, salaryDelta:0, cost:0 },
        { name:"Glass Display Case", oppDelta:-8, salaryDelta:0, cost:250 },
        { name:"Locked Case", oppDelta:-15, salaryDelta:0.5, cost:450 },
        { name:"Secure Vault Storage", oppDelta:-25, salaryDelta:1.0, cost:800 }
      ],

      guardianship: [
        { name:"Basic Service", motDelta:0, salaryDelta:0, cost:0 },
        { name:"Improved Lighting", motDelta:-4, salaryDelta:0.2, cost:150 },
        { name:"Professional Staff", motDelta:-8, salaryDelta:0.6, cost:350 },
        { name:"Luxury Concierge", motDelta:-14, salaryDelta:1.2, cost:700 }
      ]
    }
  },

  Clothing: {

    profit: [
      { name:"Standard Layout", revenueDelta:0, oppDelta:0, salaryDelta:0, cost:0 },
      { name:"Self-Service Design", revenueDelta:4, oppDelta:4, salaryDelta:-0.2, cost:150 },
      { name:"Fast Fashion Model", revenueDelta:8, oppDelta:7, salaryDelta:-0.4, cost:300 },
      { name:"Express Checkout", revenueDelta:12, oppDelta:10, salaryDelta:-0.7, cost:500 }
    ],

    security: {

      targetHardening: [
        { name:"Open Racks", oppDelta:0, salaryDelta:0, cost:0 },
        { name:"Security Tags", oppDelta:-5, salaryDelta:0, cost:120 },
        { name:"Fitting Room Control", oppDelta:-10, salaryDelta:0.3, cost:250 },
        { name:"Controlled Entry System", oppDelta:-18, salaryDelta:0.8, cost:500 }
      ],

      guardianship: [
        { name:"Minimal Staffing", motDelta:0, salaryDelta:0, cost:0 },
        { name:"Floor Assistants", motDelta:-3, salaryDelta:0.3, cost:120 },
        { name:"Customer Engagement", motDelta:-6, salaryDelta:0.6, cost:300 },
        { name:"Premium Service", motDelta:-10, salaryDelta:1.1, cost:550 }
      ]
    }
  },

  FoodCourt: {

    profit: [
      { name:"Basic Counter", revenueDelta:0, oppDelta:0, salaryDelta:0, cost:0 },
      { name:"Self-Order Kiosks", revenueDelta:3, oppDelta:3, salaryDelta:-0.3, cost:120 },
      { name:"Mobile Ordering", revenueDelta:6, oppDelta:5, salaryDelta:-0.5, cost:250 },
      { name:"Fully Automated", revenueDelta:10, oppDelta:8, salaryDelta:-0.8, cost:450 }
    ],

    security: {

      targetHardening: [
        { name:"Open Counter Service", oppDelta:0, salaryDelta:0, cost:0 },
        { name:"Queue Management", oppDelta:-3, salaryDelta:0, cost:80 },
        { name:"Controlled Payment", oppDelta:-7, salaryDelta:0.4, cost:200 },
        { name:"Cashless System", oppDelta:-12, salaryDelta:0.7, cost:400 }
      ],

      guardianship: [
        { name:"Basic Operation", motDelta:0, salaryDelta:0, cost:0 },
        { name:"Shift Supervisor", motDelta:-2, salaryDelta:0.3, cost:120 },
        { name:"Clean & Safe Initiative", motDelta:-5, salaryDelta:0.5, cost:250 },
        { name:"High Efficiency Model", motDelta:-9, salaryDelta:1.0, cost:450 }
      ]
    }
  },

  Pharmacy: {

    profit: [
      { name:"Traditional Counter", revenueDelta:0, oppDelta:0, salaryDelta:0, cost:0 },
      { name:"Self-Service Displays", revenueDelta:6, oppDelta:5, salaryDelta:-0.3, cost:180 },
      { name:"Health & Beauty Focus", revenueDelta:12, oppDelta:8, salaryDelta:-0.5, cost:350 },
      { name:"Premium Wellness Brand", revenueDelta:20, oppDelta:12, salaryDelta:-0.7, cost:600 }
    ],

    security: {

      targetHardening: [
        { name:"Open Shelving", oppDelta:0, salaryDelta:0, cost:0 },
        { name:"High-Value Item Locks", oppDelta:-6, salaryDelta:0.2, cost:150 },
        { name:"Prescription Counter Barrier", oppDelta:-12, salaryDelta:0.5, cost:300 },
        { name:"Secured Cosmetics Cabinet", oppDelta:-18, salaryDelta:0.8, cost:500 }
      ],

      guardianship: [
        { name:"Pharmacist Only", motDelta:0, salaryDelta:0, cost:0 },
        { name:"Pharmacy Assistant", motDelta:-3, salaryDelta:0.3, cost:140 },
        { name:"Active Floor Presence", motDelta:-6, salaryDelta:0.7, cost:300 },
        { name:"Health Advisor Team", motDelta:-10, salaryDelta:1.1, cost:550 }
      ]
    }
  },

  Supermarket: {

    profit: [
      { name:"Standard Layout", revenueDelta:0, oppDelta:0, salaryDelta:0, cost:0 },
      { name:"Self-Checkout Lanes", revenueDelta:5, oppDelta:6, salaryDelta:-0.4, cost:200 },
      { name:"Loyalty Card System", revenueDelta:9, oppDelta:9, salaryDelta:-0.6, cost:400 },
      { name:"Scan & Go Technology", revenueDelta:15, oppDelta:14, salaryDelta:-1.0, cost:700 }
    ],

    security: {

      targetHardening: [
        { name:"Open Aisles", oppDelta:0, salaryDelta:0, cost:0 },
        { name:"Exit Gates", oppDelta:-4, salaryDelta:0.2, cost:100 },
        { name:"Bagging Area Sensors", oppDelta:-8, salaryDelta:0.4, cost:250 },
        { name:"Smart Cart Tracking", oppDelta:-14, salaryDelta:0.7, cost:500 }
      ],

      guardianship: [
        { name:"Minimal Staffing", motDelta:0, salaryDelta:0, cost:0 },
        { name:"Aisle Monitors", motDelta:-2, salaryDelta:0.3, cost:130 },
        { name:"Roaming Security", motDelta:-5, salaryDelta:0.6, cost:280 },
        { name:"Loss Prevention Team", motDelta:-9, salaryDelta:1.0, cost:500 }
      ]
    }
  },

  ToyShop: {

    profit: [
      { name:"Traditional Display", revenueDelta:0, oppDelta:0, salaryDelta:0, cost:0 },
      { name:"Interactive Demo Stations", revenueDelta:6, oppDelta:4, salaryDelta:0.2, cost:180 },
      { name:"Seasonal Merchandising", revenueDelta:11, oppDelta:7, salaryDelta:0.3, cost:350 },
      { name:"Experience Store Model", revenueDelta:18, oppDelta:10, salaryDelta:0.5, cost:600 }
    ],

    security: {

      targetHardening: [
        { name:"Open Shelves", oppDelta:0, salaryDelta:0, cost:0 },
        { name:"Packaging Security", oppDelta:-5, salaryDelta:0.1, cost:130 },
        { name:"High-Value Item Cabinets", oppDelta:-10, salaryDelta:0.4, cost:280 },
        { name:"Smart Shelf Sensors", oppDelta:-16, salaryDelta:0.7, cost:500 }
      ],

      guardianship: [
        { name:"Self-Service Browse", motDelta:0, salaryDelta:0, cost:0 },
        { name:"Play Area Supervision", motDelta:-3, salaryDelta:0.3, cost:140 },
        { name:"Active Sales Assistance", motDelta:-6, salaryDelta:0.7, cost:300 },
        { name:"Family-Focused Service", motDelta:-10, salaryDelta:1.1, cost:550 }
      ]
    }
  },
  
  TechAccessories: {
    profit: [
      { name:"Basic Display", revenueDelta:0, oppDelta:0, salaryDelta:0, cost:0 },
      { name:"Display Fixtures", revenueDelta:7, oppDelta:5, salaryDelta:0.2, cost:190 },
      { name:"Bundle Deals", revenueDelta:13, oppDelta:8, salaryDelta:0.3, cost:380 },
      { name:"Premium Accessories", revenueDelta:20, oppDelta:12, salaryDelta:0.5, cost:650 }
    ],
    security: {
      targetHardening: [
        { name:"Open Display", oppDelta:0, salaryDelta:0, cost:0 },
        { name:"Security Packaging", oppDelta:-6, salaryDelta:0.1, cost:140 },
        { name:"Locked Display Cases", oppDelta:-12, salaryDelta:0.4, cost:300 },
        { name:"Spider Wrap Systems", oppDelta:-18, salaryDelta:0.7, cost:550 }
      ],
      guardianship: [
        { name:"Minimal Staff", motDelta:0, salaryDelta:0, cost:0 },
        { name:"Sales Associates", motDelta:-4, salaryDelta:0.3, cost:150 },
        { name:"Customer Engagement", motDelta:-7, salaryDelta:0.7, cost:320 },
        { name:"Tech Specialists", motDelta:-11, salaryDelta:1.2, cost:600 }
      ]
    }
  },
  
  Bookstore: {
    profit: [
      { name:"Traditional Bookstore", revenueDelta:0, oppDelta:0, salaryDelta:0, cost:0 },
      { name:"Coffee Bar Integration", revenueDelta:6, oppDelta:3, salaryDelta:0.3, cost:170 },
      { name:"Events Space", revenueDelta:11, oppDelta:5, salaryDelta:0.5, cost:340 },
      { name:"Lifestyle Merchandise", revenueDelta:17, oppDelta:8, salaryDelta:0.7, cost:580 }
    ],
    security: {
      targetHardening: [
        { name:"Open Shelves", oppDelta:0, salaryDelta:0, cost:0 },
        { name:"Security Tags", oppDelta:-4, salaryDelta:0.1, cost:120 },
        { name:"Exit Gate System", oppDelta:-8, salaryDelta:0.3, cost:250 },
        { name:"Rare Book Security", oppDelta:-13, salaryDelta:0.5, cost:480 }
      ],
      guardianship: [
        { name:"Browse Freely", motDelta:0, salaryDelta:0, cost:0 },
        { name:"Floor Staff", motDelta:-3, salaryDelta:0.2, cost:130 },
        { name:"Recommendation Service", motDelta:-5, salaryDelta:0.5, cost:280 },
        { name:"Community Presence", motDelta:-8, salaryDelta:0.9, cost:520 }
      ]
    }
  },
  
  LuxuryGoods: {
    profit: [
      { name:"Standard Retail", revenueDelta:0, oppDelta:0, salaryDelta:0, cost:0 },
      { name:"Private Appointments", revenueDelta:12, oppDelta:6, salaryDelta:0.5, cost:280 },
      { name:"Exclusive Collections", revenueDelta:22, oppDelta:10, salaryDelta:0.9, cost:560 },
      { name:"Luxury Concierge", revenueDelta:35, oppDelta:15, salaryDelta:1.5, cost:950 }
    ],
    security: {
      targetHardening: [
        { name:"Display Cases", oppDelta:0, salaryDelta:0, cost:0 },
        { name:"Vault Storage", oppDelta:-8, salaryDelta:0.2, cost:220 },
        { name:"Reinforced Security", oppDelta:-15, salaryDelta:0.5, cost:450 },
        { name:"Biometric Access", oppDelta:-24, salaryDelta:0.9, cost:800 }
      ],
      guardianship: [
        { name:"Basic Service", motDelta:0, salaryDelta:0, cost:0 },
        { name:"Personal Shoppers", motDelta:-5, salaryDelta:0.4, cost:200 },
        { name:"Appointment Only", motDelta:-9, salaryDelta:0.9, cost:420 },
        { name:"Security Greeter", motDelta:-14, salaryDelta:1.5, cost:750 }
      ]
    }
  },
  
  Entertainment: {
    profit: [
      { name:"Basic Venue", revenueDelta:0, oppDelta:0, salaryDelta:0, cost:0 },
      { name:"Concessions", revenueDelta:4, oppDelta:2, salaryDelta:0.2, cost:150 },
      { name:"Merchandise Sales", revenueDelta:8, oppDelta:4, salaryDelta:0.4, cost:300 },
      { name:"Premium Experiences", revenueDelta:13, oppDelta:6, salaryDelta:0.6, cost:520 }
    ],
    security: {
      targetHardening: [
        { name:"Open Merchandise", oppDelta:0, salaryDelta:0, cost:0 },
        { name:"Display Security", oppDelta:-3, salaryDelta:0.1, cost:110 },
        { name:"Improved Lighting", oppDelta:-6, salaryDelta:0.2, cost:230 },
        { name:"Point of Sale Only", oppDelta:-10, salaryDelta:0.4, cost:450 }
      ],
      guardianship: [
        { name:"Minimal Staff", motDelta:0, salaryDelta:0, cost:0 },
        { name:"Concession Staff", motDelta:-2, salaryDelta:0.2, cost:120 },
        { name:"Active Ushers", motDelta:-4, salaryDelta:0.5, cost:260 },
        { name:"Customer Service Team", motDelta:-7, salaryDelta:0.9, cost:500 }
      ]
    }
  },

  WineShop: {
    profit: [
      { name:"Basic Selection", revenueDelta:0, oppDelta:0, salaryDelta:0, cost:0 },
      { name:"Premium Wines", revenueDelta:8, oppDelta:4, salaryDelta:0.3, cost:200 },
      { name:"Tasting Events", revenueDelta:15, oppDelta:7, salaryDelta:0.6, cost:400 },
      { name:"Rare Collection", revenueDelta:24, oppDelta:10, salaryDelta:1.0, cost:700 }
    ],
    security: {
      targetHardening: [
        { name:"Open Shelves", oppDelta:0, salaryDelta:0, cost:0 },
        { name:"Bottle Security", oppDelta:-5, salaryDelta:0.2, cost:150 },
        { name:"Locked High-End", oppDelta:-10, salaryDelta:0.4, cost:320 },
        { name:"Vault Storage", oppDelta:-16, salaryDelta:0.7, cost:600 }
      ],
      guardianship: [
        { name:"Self-Service", motDelta:0, salaryDelta:0, cost:0 },
        { name:"Wine Adviser", motDelta:-4, salaryDelta:0.3, cost:140 },
        { name:"Sommelier Service", motDelta:-7, salaryDelta:0.6, cost:300 },
        { name:"Personal Consultation", motDelta:-11, salaryDelta:1.0, cost:550 }
      ]
    }
  },

  Cinema: {
    profit: [
      { name:"Standard Admission", revenueDelta:0, oppDelta:0, salaryDelta:0, cost:0 },
      { name:"Premium Snacks", revenueDelta:5, oppDelta:2, salaryDelta:0.2, cost:120 },
      { name:"VIP Seating", revenueDelta:9, oppDelta:4, salaryDelta:0.4, cost:250 },
      { name:"Luxury Experience", revenueDelta:14, oppDelta:6, salaryDelta:0.6, cost:450 }
    ],
    security: {
      targetHardening: [
        { name:"Open Lobby", oppDelta:0, salaryDelta:0, cost:0 },
        { name:"Ticket Gates", oppDelta:-3, salaryDelta:0.1, cost:90 },
        { name:"Security Cameras", oppDelta:-6, salaryDelta:0.2, cost:190 },
        { name:"Controlled Access", oppDelta:-10, salaryDelta:0.3, cost:380 }
      ],
      guardianship: [
        { name:"Ticket Booth Only", motDelta:0, salaryDelta:0, cost:0 },
        { name:"Floor Ushers", motDelta:-2, salaryDelta:0.2, cost:100 },
        { name:"Active Monitoring", motDelta:-4, salaryDelta:0.4, cost:220 },
        { name:"Security Team", motDelta:-7, salaryDelta:0.7, cost:420 }
      ]
    }
  },

  Bowling: {
    profit: [
      { name:"Basic Lanes", revenueDelta:0, oppDelta:0, salaryDelta:0, cost:0 },
      { name:"Food Service", revenueDelta:4, oppDelta:2, salaryDelta:0.2, cost:110 },
      { name:"Bar & Grill", revenueDelta:8, oppDelta:4, salaryDelta:0.4, cost:230 },
      { name:"Party Packages", revenueDelta:12, oppDelta:6, salaryDelta:0.6, cost:420 }
    ],
    security: {
      targetHardening: [
        { name:"Open Floor", oppDelta:0, salaryDelta:0, cost:0 },
        { name:"Shoe Security", oppDelta:-3, salaryDelta:0.1, cost:80 },
        { name:"Equipment Check", oppDelta:-6, salaryDelta:0.2, cost:170 },
        { name:"Lane Monitoring", oppDelta:-9, salaryDelta:0.3, cost:350 }
      ],
      guardianship: [
        { name:"Counter Staff", motDelta:0, salaryDelta:0, cost:0 },
        { name:"Lane Attendants", motDelta:-2, salaryDelta:0.2, cost:90 },
        { name:"Active Staff", motDelta:-4, salaryDelta:0.4, cost:200 },
        { name:"Full Service Team", motDelta:-6, salaryDelta:0.6, cost:390 }
      ]
    }
  },

  Arcade: {
    profit: [
      { name:"Token System", revenueDelta:0, oppDelta:0, salaryDelta:0, cost:0 },
      { name:"Prize Counter", revenueDelta:3, oppDelta:2, salaryDelta:0.1, cost:90 },
      { name:"Premium Games", revenueDelta:6, oppDelta:3, salaryDelta:0.3, cost:190 },
      { name:"Tournament Events", revenueDelta:10, oppDelta:5, salaryDelta:0.5, cost:350 }
    ],
    security: {
      targetHardening: [
        { name:"Coin-Op Only", oppDelta:0, salaryDelta:0, cost:0 },
        { name:"Card System", oppDelta:-2, salaryDelta:0.1, cost:70 },
        { name:"Machine Locks", oppDelta:-5, salaryDelta:0.2, cost:150 },
        { name:"Prize Security", oppDelta:-8, salaryDelta:0.3, cost:310 }
      ],
      guardianship: [
        { name:"Unstaffed", motDelta:0, salaryDelta:0, cost:0 },
        { name:"Token Booth", motDelta:-1, salaryDelta:0.1, cost:80 },
        { name:"Floor Monitor", motDelta:-3, salaryDelta:0.3, cost:170 },
        { name:"Active Supervision", motDelta:-5, salaryDelta:0.5, cost:340 }
      ]
    }
  }

};

/* ======================
   UPGRADES
====================== */

function previewProfitModel(i){
  const shop = shops[i];
  if(shop.strategy !== null && shop.strategy !== "profit_preview" && shop.strategy !== "security_preview") return;

  shop.strategy = "profit_preview";
  buildSelectedShopUI();
}

function previewSecurityModel(i){
  const shop = shops[i];
  if(shop.strategy !== null && shop.strategy !== "profit_preview" && shop.strategy !== "security_preview") return;

  shop.strategy = "security_preview";
  buildSelectedShopUI();
}

function confirmProfitModel(i){
  const shop = shops[i];
  if(shop.strategy !== "profit_preview") return;

  shop.strategy = "profit";
  shop.profitTier = 0;

  buildSelectedShopUI();
}

function confirmSecurityModel(i){
  const shop = shops[i];
  if(shop.strategy !== "security_preview") return;

  shop.strategy = "security";
  shop.hardeningTier = 0;
  shop.guardianshipTier = 0;

  buildSelectedShopUI();
}

function cancelStrategy(i){
  const shop = shops[i];
  if(shop.strategy !== "profit_preview" && shop.strategy !== "security_preview") return;

  shop.strategy = null;
  buildSelectedShopUI();
}

function upgradeProfit(i){
  if(gamePhase !== "planning") return;

  const shop = shops[i];
  // Allow upgrade if primary profit strategy OR if profit branch unlocked from security
  if(shop.strategy !== "profit" && !shop.profitBranchUnlocked) return;

  const track = storeUpgradeData[shop.type].profit;
  if(shop.profitTier >= track.length - 1) return;

  const next = track[shop.profitTier + 1];
  if(money < next.cost) return;

  money -= next.cost;
  shop.profitTier++;

  // Apply deltas
  shop.revenueBonus += next.revenueDelta;
  shop.baseOpportunity += next.oppDelta;
  shop.salary += next.salaryDelta;

  buildSelectedShopUI();
}

function chooseSecurityModel(i){
  const shop = shops[i];
  if(shop.strategy !== null) return;

  shop.strategy = "security";
  shop.hardeningTier = 0;
  shop.guardianshipTier = 0;

  buildSelectedShopUI();
}

function upgradeTargetHardening(i){
  if(gamePhase !== "planning") return;

  const shop = shops[i];
  // Allow upgrade if primary security strategy OR if security branch unlocked from profit
  if(shop.strategy !== "security" && !shop.securityBranchUnlocked) return;

  const track = storeUpgradeData[shop.type].security.targetHardening;
  if(shop.hardeningTier >= track.length - 1) return;

  const next = track[shop.hardeningTier + 1];
  if(money < next.cost) return;

  money -= next.cost;
  shop.hardeningTier++;

  // Apply deltas
  shop.baseOpportunity += next.oppDelta;
  shop.salary += next.salaryDelta;
  
  // Invalidate camera synergy cache
  cameras.forEach(c => c.synergyBonus = undefined);

  buildSelectedShopUI();
}

function upgradeGuardianship(i){
  if(gamePhase !== "planning") return;

  const shop = shops[i];
  if(shop.strategy !== "security") return;

  const track = storeUpgradeData[shop.type].security.guardianship;
  if(shop.guardianshipTier >= track.length - 1) return;

  const next = track[shop.guardianshipTier + 1];
  if(money < next.cost) return;

  money -= next.cost;
  shop.guardianshipTier++;

  // Apply deltas (guardianship affects motivation during theft check)
  shop.salary += next.salaryDelta;
  
  // Invalidate guard synergy cache
  guards.forEach(g => g.synergyBonus = undefined);

  buildSelectedShopUI();
}

function unlockSecurityBranch(i){
  if(gamePhase !== "planning") return;
  
  const shop = shops[i];
  if(shop.strategy !== "profit") return;
  if(shop.securityBranchUnlocked) return;
  if(money < 500) return;
  
  money -= 500;
  shop.securityBranchUnlocked = true;
  shop.hardeningTier = 0; // Start at tier 0
  
  buildSelectedShopUI();
}

function unlockProfitBranch(i){
  if(gamePhase !== "planning") return;
  
  const shop = shops[i];
  if(shop.strategy !== "security") return;
  if(shop.profitBranchUnlocked) return;
  if(money < 500) return;
  
  money -= 500;
  shop.profitBranchUnlocked = true;
  shop.profitTier = 0; // Start at tier 0
  
  buildSelectedShopUI();
}

function upgradeCCTV(){
  if(gamePhase !== "planning") return;
  if(cctvLevel >= maxLevel) return;

  const cost = upgradeCost(120, cctvLevel);
  if(money < cost) return;

  money -= cost;
  cctvLevel++;
  buildCCTVUI(); updateCameraButton();
  updateCameraButton();
}

/* ======================
   PHASE CONTROL
====================== */
function checkShopUnlocks(){
  console.log('=== checkShopUnlocks called ===');
  console.log('Wave:', waveNumber, 'Rep:', reputation);
  console.log('Currently unlocked:', unlockedShops);
  
  availableShopUnlocks = [];
  
  unlockableShops.forEach(unlock => {
    // Check if already unlocked
    if(unlockedShops.includes(unlock.id)){
      console.log(`  ${unlock.id}: SKIP (already unlocked)`);
      return;
    }
    
    // Check wave and reputation requirements
    const hasPrerequisite = !unlock.requires || unlock.requires.every(req => unlockedShops.includes(req));
    if(waveNumber >= unlock.wave && reputation >= unlock.minRep && hasPrerequisite){
      console.log(`  ${unlock.id}: AVAILABLE (wave ${unlock.wave}, rep ${unlock.minRep})`);
      availableShopUnlocks.push(unlock);
    } else {
      console.log(`  ${unlock.id}: NOT YET (needs wave ${unlock.wave}, rep ${unlock.minRep}, prereq: ${unlock.requires})`);
    }
  });
  
  console.log('Final available list:', availableShopUnlocks.map(u => u.id));
  
  // Always update UI to show or hide panel appropriately
  buildShopUnlockUI();
}

function unlockShop(unlockId){
  const unlock = unlockableShops.find(u => u.id === unlockId);
  if(!unlock) return;
  
  console.log('Unlocking shop:', unlockId);
  console.log('Already unlocked list:', unlockedShops);
  
  // Check if already unlocked
  if(unlockedShops.includes(unlockId)){
    console.log('BLOCKED: Shop already unlocked!');
    return; // Already unlocked, do nothing
  }
  
  // Check if can afford
  if(money < unlock.cost){
    alert(`Not enough money! Need ¬£${unlock.cost}`);
    return;
  }
  
  // Deduct cost
  money -= unlock.cost;
  
  // Handle multi-shop unlocks (Wave 7 & 10)
  if(unlock.multiShop && unlock.shops){
    // Add all shops in the bundle
    unlock.shops.forEach(shopData => {
      shops.push({...shopData});
      nodes[shopData.node].unlocked = true;
      
      // Update shop lookup map
      shopByNode[shopData.node] = shops[shops.length - 1];
    });
    
    // Mark as unlocked
    unlockedShops.push(unlock.id);
    
    console.log(`Unlocked ${unlock.shops.length} shops!`);
    
    // Special unlock logic for luxury district
    if(unlockId === "luxurydistrict"){
      nodes.northeastJunction.unlocked = true;
      newPathUnlocked = true;
    }
    
    // Special unlock logic for entertainment complex
    if(unlockId === "entertainmentcomplex"){
      nodes.southJunction.unlocked = true;
      newPathUnlocked = true;
    }
  } else {
    // Single shop unlock (Wave 3 & 5)
    shops.push({...unlock.shop});
    
    // Mark as unlocked
    unlockedShops.push(unlock.id);
    nodes[unlock.id].unlocked = true;
    
    console.log('Unlocked! New list:', unlockedShops);
    
    // Update shop lookup map with the new shop
    const newShop = shops[shops.length - 1];
    shopByNode[newShop.node] = newShop;
  }
  
  // Remove from available unlocks
  availableShopUnlocks = availableShopUnlocks.filter(u => u.id !== unlockId);
  
  console.log('Available unlocks after filter:', availableShopUnlocks.map(u => u.id));
  
  // Update UI - recheck all unlocks to properly hide panel if empty
  checkShopUnlocks();
  buildSelectedShopUI();
  
  // Show success message
  if(unlock.multiShop){
    console.log(`${unlock.shops.length} shops opened for ¬£${unlock.cost}!`);
  } else {
    console.log(`${unlock.shop.name} opened for ¬£${unlock.cost}!`);
  }
}

function buildShopUnlockUI(){
  const container = document.getElementById("shopUnlockPanel");
  if(!container) return;
  
  // Also find unlocks that are wave/rep eligible but missing prerequisites
  const lockedByPrereq = unlockableShops.filter(unlock => {
    if(unlockedShops.includes(unlock.id)) return false;
    if(availableShopUnlocks.includes(unlock)) return false;
    if(!unlock.requires) return false;
    const hasPrereq = unlock.requires.some(req => unlockedShops.includes(req));
    return !hasPrereq && waveNumber >= unlock.wave && reputation >= unlock.minRep;
  });
  
  if(availableShopUnlocks.length === 0 && lockedByPrereq.length === 0){
    container.innerHTML = "";
    container.style.display = "none";
    return;
  }
  
  container.style.display = "block";
  let html = "<b>üè™ New Shops Available</b><br><br>";
  
  availableShopUnlocks.forEach(unlock => {
    const canAfford = money >= unlock.cost;
    
    if(unlock.multiShop && unlock.shops){
      const shopNames = unlock.shops.map(s => s.name).join(", ");
      const totalValue = unlock.shops.reduce((sum, s) => sum + s.value, 0);
      
      html += `
        <div style="margin-bottom:10px; padding:8px; background:#2a2a2a; border-radius:4px;">
          <b>${shopNames}</b><br>
          <span class="small">
            ${unlock.shops.length} shops, Total Value: ¬£${totalValue}<br>
            Cost: ¬£${unlock.cost}<br>
            Req: Wave ${unlock.wave}, Rep ${unlock.minRep}+
          </span><br>
          <button onclick="unlockShop('${unlock.id}')" ${!canAfford ? 'disabled' : ''}>
            Open District (¬£${unlock.cost})
          </button>
        </div>
      `;
    } else {
      html += `
        <div style="margin-bottom:10px; padding:8px; background:#2a2a2a; border-radius:4px;">
          <b>${unlock.shop.name}</b><br>
          <span class="small">
            Value: ¬£${unlock.shop.value}<br>
            Cost: ¬£${unlock.cost}<br>
            Req: Wave ${unlock.wave}, Rep ${unlock.minRep}+
          </span><br>
          <button onclick="unlockShop('${unlock.id}')" ${!canAfford ? 'disabled' : ''}>
            Open Shop (¬£${unlock.cost})
          </button>
        </div>
      `;
    }
  });
  
  // Show locked-by-prereq unlocks with hint
  lockedByPrereq.forEach(unlock => {
    const prereqNames = unlock.requires.map(req => {
      const u = unlockableShops.find(u => u.id === req);
      return u ? (u.shop ? u.shop.name : u.shops?.[0]?.name) : req;
    }).join(" and ");
    
    const allMet = unlock.requires.every(req => unlockedShops.includes(req));
    const metCount = unlock.requires.filter(req => unlockedShops.includes(req)).length;
    const progress = unlock.requires.length > 1 ? ` (${metCount}/${unlock.requires.length})` : "";
    
    html += `
      <div style="margin-bottom:10px; padding:8px; background:#1a1a1a; border-radius:4px; opacity:0.6;">
        <b>${unlock.multiShop ? unlock.shops.map(s=>s.name).join(", ") : unlock.shop.name}</b><br>
        <span class="small" style="color:#ff9800;">
          üîí Requires: ${prereqNames}${progress}
        </span>
      </div>
    `;
  });
  
  container.innerHTML = html;
}

function startWave(){
  if(gamePhase !== "planning") return;
  if(isMobile()) setMobileTab('canvas'); // Show map when wave begins

  // reset shop heat each wave
  shops.forEach(shop => shop.theftCount = 0);

  waveStats = {
    mallRevenue: 0,
    theftLoss: 0,
    thefts: 0,
    offenders: new Set(),
    salaryPaid: 0,
    visitorTypes: { ordinary: 0, opportunist: 0, determined: 0, specialist: 0, flashmob: 0, crew: 0, bigspender: 0 },
    theftsByType: { ordinary: 0, opportunist: 0, determined: 0, specialist: 0, flashmob: 0, crew: 0 },
    flashMobLoss: 0,
    flashMobRepLoss: 0,
    crewLoss: 0,
    crewRepLoss: 0,
    shopThefts: {},
    shopLosses: {},
    repStart: reputation,
    shopRepStart: Object.fromEntries(shops.map((s, i) => [i, s.rep]))
  };

  // Reset organised crime state
  flashMobPending = false;
  flashMobTimer = 0;
  flashMobWarningShown = false;
  crewScoutActive = false;
  crewScoutId = null;
  crewPending = false;
  crewTimer = 0;
  crewWarningShown = false;
  crewScoutCaught = false;

  // === ROLL FOR FLASH MOB ONCE AT WAVE START ===
  if(waveNumber >= 9 && reputation >= 45){
    const flashMobChance = Math.min(0.9, 0.40 + (waveNumber - 9) * 0.05);
    if(Math.random() < flashMobChance){
      flashMobPending = true;
      const arrivalWindow = waveLength * 0.30;
      flashMobTimer = arrivalWindow * (0.1 + Math.random() * 0.7);
      flashMobWarningShown = true;
      setTimeout(() => {
        if(gamePhase === "wave") showEventNotification("‚ö° Large group gathering outside...", "#ff9800");
      }, Math.max(0, (flashMobTimer - 5) * 1000));
    }
  }
  
  // MUTUAL EXCLUSION: Flash mob and crew can't occur same wave
  // unless rep >= 400 AND wave >= 20 (elite late-game scenario)
  if(flashMobPending && !(reputation >= 400 && waveNumber >= 20)){
    crewWarningShown = true; // Block crew from spawning this wave
  }

  gamePhase = "wave";
  // Wave length grows with wave number: +1s per wave, capped at 50s
  waveLength = Math.min(50, 30 + (waveNumber - 1));
  waveTimer = waveLength;
  setRightMode("wave");
}

function endWave(){
  gamePhase = "planning";
  waveNumber++;
  document.getElementById("waveNum").innerText = waveNumber;
  visitors = [];
  
  // Check for new shop unlocks
  checkShopUnlocks();
  
  // DON'T clear waveStats - keep them visible for planning phase
  // They'll be cleared when starting the next wave
}

function resetGame(){
  // Confirm reset
  if(!confirm("Are you sure you want to reset the game? All progress will be lost.")) return;
  
  // Reset game state
  money = 1500;
  reputation = 25;
  placingGuard = false;
  placingCamera = false;
  cameraPlacementStep = 0;
  tempCamera = null;
  selectedShopIndex = null;
  hoveredShopIndex = null;
  gamePhase = "planning";
  waveTimer = 0;
  waveNumber = 1;
  waveLength = 30;
  cctvLevel = 0;
  flashMobKnowledge = 0;
  crewKnowledge = 0;
  
  // Reset guards and visitors
  guards.length = 0;
  cameras.length = 0;
  visitors = [];
  
  // Clear visual effects
  floatingTexts = [];
  particles = [];
  preventionIndicators = [];
  
  // Reset shop unlocks
  unlockedShops = [];
  availableShopUnlocks = [];
  newPathUnlocked = false;
  // Mark all unlockable shops and transit nodes as locked
  nodes.techaccessories.unlocked = false;
  nodes.bookstore.unlocked = false;
  nodes.northeastJunction.unlocked = false;
  nodes.luxurygoods.unlocked = false;
  nodes.wineshop.unlocked = false;
  nodes.southJunction.unlocked = false;
  nodes.cinema.unlocked = false;
  nodes.bowling.unlocked = false;
  nodes.arcade.unlocked = false;
  nodes.foodcourt2.unlocked = false;
  // Remove unlocked shops from shops array (keep only original 7)
  const originalShopTypes = ["Electronics", "Clothing", "Jewellery", "FoodCourt", "Pharmacy", "Supermarket", "ToyShop"];
  shops.length = 0;
  shops.push(
    ...[ 
      {name:"Electronics", type:"Electronics", node:"north", value:70, baseOpportunity:25, strategy:null, profitTier:0, hardeningTier:0, guardianshipTier:0, revenueBonus:0, salary:0, rep:25, theftCount:0},
      {name:"Clothing", type:"Clothing", node:"east", value:40, baseOpportunity:20, strategy:null, profitTier:0, hardeningTier:0, guardianshipTier:0, revenueBonus:0, salary:0, rep:25, theftCount:0},
      {name:"Jewellery", type:"Jewellery", node:"south", value:100, baseOpportunity:35, strategy:null, profitTier:0, hardeningTier:0, guardianshipTier:0, revenueBonus:0, salary:0, rep:25, theftCount:0},
      {name:"Food Court", type:"FoodCourt", node:"food", value:25, baseOpportunity:10, strategy:null, profitTier:0, hardeningTier:0, guardianshipTier:0, revenueBonus:0, salary:0, rep:25, theftCount:0},
      {name:"Pharmacy", type:"Pharmacy", node:"pharmacy", value:55, baseOpportunity:28, strategy:null, profitTier:0, hardeningTier:0, guardianshipTier:0, revenueBonus:0, salary:0, rep:25, theftCount:0},
      {name:"Supermarket", type:"Supermarket", node:"supermarket", value:35, baseOpportunity:22, strategy:null, profitTier:0, hardeningTier:0, guardianshipTier:0, revenueBonus:0, salary:0, rep:25, theftCount:0},
      {name:"Toy Shop", type:"ToyShop", node:"toyshop", value:50, baseOpportunity:24, strategy:null, profitTier:0, hardeningTier:0, guardianshipTier:0, revenueBonus:0, salary:0, rep:25, theftCount:0}
    ]
  );
  
  // Rebuild shop by node mapping
  Object.keys(shopByNode).forEach(key => delete shopByNode[key]);
  shops.forEach(shop => {
    shopByNode[shop.node] = shop;
  });
  
  // Reset all remaining shops
  shops.forEach(shop => {
    shop.strategy = null;
    shop.profitTier = 0;
    shop.hardeningTier = 0;
    shop.guardianshipTier = 0;
    shop.revenueBonus = 0;
    shop.salary = 0;
    shop.rep = 25;
    shop.theftCount = 0;
    shop.securityBranchUnlocked = false;
    shop.profitBranchUnlocked = false;
    
    // Reset to base values
    if(shop.type === "Electronics"){
      shop.baseOpportunity = 25;
    } else if(shop.type === "Clothing"){
      shop.baseOpportunity = 20;
    } else if(shop.type === "Jewellery"){
      shop.baseOpportunity = 35;
    } else if(shop.type === "FoodCourt"){
      shop.baseOpportunity = 10;
    } else if(shop.type === "Pharmacy"){
      shop.baseOpportunity = 28;
    } else if(shop.type === "Supermarket"){
      shop.baseOpportunity = 22;
    } else if(shop.type === "ToyShop"){
      shop.baseOpportunity = 24;
    }
  });
  
  // Reset wave stats
  waveStats = {
    mallRevenue: 0,
    theftLoss: 0,
    thefts: 0,
    offenders: new Set(),
    salaryPaid: 0,
    visitorTypes: { ordinary: 0, opportunist: 0, determined: 0, specialist: 0 },
    theftsByType: { ordinary: 0, opportunist: 0, determined: 0, specialist: 0 },
    shopThefts: {},
    shopLosses: {}
  };
  
  // Rebuild UI
  document.getElementById("waveNum").innerText = waveNumber;
  document.getElementById("analyticsPanel").innerHTML = "Start a wave to see results.";
  buildSelectedShopUI();
  buildCCTVUI(); updateCameraButton();
  buildShopUnlockUI(); // Clear unlock panel
  setRightMode("wave");
}

/* ======================
   GUARDS
====================== */
function addGuard(){
  if(gamePhase !== "planning") return;
  if(money < 150) return;

  placingGuard = true;
  canvas.style.cursor = "crosshair";
}

/* ======================
   GUARDS & CAMERAS
====================== */

function calculateGuardPatrolPath(x, y){
  // Check if guard is in/near a shop
  for(let i = 0; i < shops.length; i++){
    const shop = shops[i];
    const node = nodes[shop.node];
    const isLarge = node.size === "large";
    const width = isLarge ? 150 : 100;
    const height = isLarge ? 90 : 60;
    
    const halfW = width / 2;
    const halfH = height / 2;
    
    // Check if guard is within shop bounds
    if(Math.abs(x - node.x) < halfW && Math.abs(y - node.y) < halfH){
      // In shop - patrol horizontally across shop
      return {
        startX: node.x - halfW + 20,
        startY: node.y,
        endX: node.x + halfW - 20,
        endY: node.y
      };
    }
  }
  
  // Not in shop - find nearest corridor and patrol along it
  let nearestCorridor = null;
  let minDist = Infinity;
  
  Object.values(nodes).forEach(node => {
    node.connections.forEach(targetId => {
      if(node.id < targetId){
        const target = nodes[targetId];
        
        // Find closest point on corridor
        const closest = closestPointOnLine(x, y, node.x, node.y, target.x, target.y);
        const dist = Math.hypot(x - closest.x, y - closest.y);
        
        if(dist < minDist){
          minDist = dist;
          
          // Calculate patrol path along this corridor (60px length centered on placement)
          const dx = target.x - node.x;
          const dy = target.y - node.y;
          const len = Math.hypot(dx, dy);
          const dirX = dx / len;
          const dirY = dy / len;
          
          nearestCorridor = {
            startX: x - dirX * 30,
            startY: y - dirY * 30,
            endX: x + dirX * 30,
            endY: y + dirY * 30
          };
        }
      }
    });
  });
  
  return nearestCorridor || {startX: x - 30, startY: y, endX: x + 30, endY: y};
}

function addGuard(){
  if(gamePhase !== "planning") return;
  if(money < 150) return;

  placingGuard = true;
  placingCamera = false;
  canvas.style.cursor = "crosshair";
}

function addCamera(){
  if(gamePhase !== "planning") return;
  if(money < 50) return;
  
  // Check camera limit
  const maxCameras = getMaxCameras();
  if(cameras.length >= maxCameras){
    alert(`Camera limit reached! Max ${maxCameras} cameras (upgrade CCTV to unlock more)`);
    return;
  }

  placingCamera = true;
  placingGuard = false;
  cameraPlacementStep = 1;
  canvas.style.cursor = "crosshair";
}

function updateCameraButton(){
  const btn = document.getElementById("placeCameraBtn");
  if(!btn) return;
  const used = cameras.length;
  const max = getMaxCameras();
  const atLimit = used >= max;
  btn.textContent = `Place Camera (¬£50) [${used}/${max}]`;
  btn.disabled = atLimit;
}

function calculateCameraAngle(x, y){
  // Find nearest shop or hub to point camera towards
  let nearestDist = Infinity;
  let nearestAngle = 0;
  
  Object.values(nodes).forEach(node => {
    const dist = Math.hypot(node.x - x, node.y - y);
    if(dist < nearestDist && dist > 20){ // not too close
      nearestDist = dist;
      nearestAngle = Math.atan2(node.y - y, node.x - x);
    }
  });
  
  return nearestAngle;
}

function snapCameraToWall(x, y){
  let minDist = Infinity;
  let snapPoint = {x, y};
  
  // First, check if we're near a shop - if so, snap to shop walls
  shops.forEach((shop, idx) => {
    const node = nodes[shop.node];
    const isLarge = node.size === "large";
    const width = isLarge ? 150 : 100;
    const height = isLarge ? 90 : 60;
    
    const halfW = width / 2;
    const halfH = height / 2;
    
    // Check if click is near this shop
    const distToShop = Math.hypot(x - node.x, y - node.y);
    
    if(distToShop < Math.max(width, height)){
      // Determine which wall is closest
      const walls = [
        { x: node.x, y: node.y - halfH, name: "top" },       // Top wall
        { x: node.x, y: node.y + halfH, name: "bottom" },    // Bottom wall
        { x: node.x - halfW, y: node.y, name: "left" },      // Left wall
        { x: node.x + halfW, y: node.y, name: "right" }      // Right wall
      ];
      
      walls.forEach(wall => {
        const dist = Math.hypot(x - wall.x, y - wall.y);
        if(dist < minDist){
          minDist = dist;
          snapPoint = {x: wall.x, y: wall.y};
        }
      });
      
      return; // Found a shop, use that
    }
  });
  
  // If not near a shop, use corridor edges
  if(minDist === Infinity){
    const corridorHalfWidth = 20; // Half of the 40px lineWidth used for corridors
    
    // Check all node connections (the actual corridors)
    Object.values(nodes).forEach(node => {
      node.connections.forEach(targetId => {
        if(node.id < targetId){ // Prevent duplicate checking
          const target = nodes[targetId];
          
          // Find closest point on this line segment
          const closest = closestPointOnLine(
            x, y,
            node.x, node.y,
            target.x, target.y
          );
          
          // Calculate perpendicular offset to edge
          const dx = target.x - node.x;
          const dy = target.y - node.y;
          const len = Math.hypot(dx, dy);
          
          // Perpendicular direction (rotated 90¬∞)
          const perpX = -dy / len;
          const perpY = dx / len;
          
          // Try both sides of the corridor
          const edge1 = {
            x: closest.x + perpX * corridorHalfWidth,
            y: closest.y + perpY * corridorHalfWidth
          };
          const edge2 = {
            x: closest.x - perpX * corridorHalfWidth,
            y: closest.y - perpY * corridorHalfWidth
          };
          
          // Check which edge is closer to click point
          const dist1 = Math.hypot(x - edge1.x, y - edge1.y);
          const dist2 = Math.hypot(x - edge2.x, y - edge2.y);
          
          if(dist1 < minDist){
            minDist = dist1;
            snapPoint = edge1;
          }
          if(dist2 < minDist){
            minDist = dist2;
            snapPoint = edge2;
          }
        }
      });
    });
  }
  
  return snapPoint;
}

function closestPointOnLine(px, py, x1, y1, x2, y2){
  // Vector from line start to point
  const dx = px - x1;
  const dy = py - y1;
  
  // Line direction vector
  const lx = x2 - x1;
  const ly = y2 - y1;
  
  // Length squared of line
  const lenSq = lx * lx + ly * ly;
  
  // Project point onto line (clamped to segment)
  let t = (dx * lx + dy * ly) / lenSq;
  t = Math.max(0, Math.min(1, t));
  
  return {
    x: x1 + t * lx,
    y: y1 + t * ly
  };
}

// CLICK HANDLER
canvas.addEventListener("click", function(e){
  if(isMobile()) return; // Mobile handled by touchend ‚Üí handleCanvasTap

  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  // 1Ô∏è‚É£ GUARD PLACEMENT
  if(placingGuard && gamePhase === "planning"){
    // Determine patrol path based on placement location
    let patrolPath = calculateGuardPatrolPath(x, y);
    
    guards.push({
      x: x,
      y: y,
      radius: 130,
      patrolPath: patrolPath,
      patrolProgress: 0,
      patrolDirection: 1
    });

    // Invalidate both synergy caches - guard placement affects camera+guard synergy
    cameras.forEach(c => c.synergyBonus = undefined);
    guards.forEach(g => g.synergyBonus = undefined);

    money -= 150;
    placingGuard = false;
    canvas.style.cursor = "default";
    return;
  }

  // 1BÔ∏è‚É£ CAMERA PLACEMENT - Two-tap system
  if(placingCamera && gamePhase === "planning"){
    
    if(cameraPlacementStep === 1){
      // First tap: place camera position (snap to wall)
      const snapped = snapCameraToWall(x, y);
      
      tempCamera = {
        x: snapped.x,
        y: snapped.y,
        angle: 0,
        range: 150,
        fov: Math.PI / 3
      };
      cameraPlacementStep = 2;
      return;
    }
    
    if(cameraPlacementStep === 2){
      // Check if click is inside the cone
      const dx = x - tempCamera.x;
      const dy = y - tempCamera.y;
      const dist = Math.hypot(dx, dy);
      const angleToClick = Math.atan2(dy, dx);
      
      let angleDiff = angleToClick - tempCamera.angle;
      while(angleDiff > Math.PI) angleDiff -= Math.PI * 2;
      while(angleDiff < -Math.PI) angleDiff += Math.PI * 2;
      
      const isInsideCone = dist < tempCamera.range && Math.abs(angleDiff) < tempCamera.fov / 2;
      
      if(!isInsideCone){
        // Click outside cone - cancel placement
        placingCamera = false;
        cameraPlacementStep = 0;
        tempCamera = null;
        canvas.style.cursor = "default";
        return;
      }
      
      // Click inside cone - finalize camera
      const angle = Math.atan2(y - tempCamera.y, x - tempCamera.x);
      tempCamera.angle = angle;
      
      cameras.push(tempCamera);
      money -= 50;
      
      // Invalidate synergy caches - new camera changes all synergy calculations
      cameras.forEach(c => c.synergyBonus = undefined);
      guards.forEach(g => g.synergyBonus = undefined);
      
      // Update UI to show new camera count
      buildCCTVUI(); updateCameraButton();
      updateCameraButton();
      
      // Reset state
      placingCamera = false;
      cameraPlacementStep = 0;
      tempCamera = null;
      canvas.style.cursor = "default";
      return;
    }
  }

  // 2Ô∏è‚É£ SHOP SELECTION
  for(let i = 0; i < shops.length; i++){
    const shop = shops[i];
    const node = nodes[shop.node];
    
    // Check if shop is large
    const isLarge = node.size === "large";
    const clickRadius = isLarge ? 75 : 60;

    if(Math.hypot(x - node.x, y - node.y) < clickRadius){
      selectedShopIndex = i;
      buildSelectedShopUI();
      return;
    }
  }

  // 3Ô∏è‚É£ CLICKED EMPTY SPACE ‚Üí DESELECT
  selectedShopIndex = null;
  buildSelectedShopUI();
});

// MOUSEMOVE HANDLER (SEPARATE)
canvas.addEventListener("mousemove", function(e){
  if(isMobile()) return;

  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  // Update temp camera angle if in step 2
  if(placingCamera && cameraPlacementStep === 2 && tempCamera){
    const angle = Math.atan2(y - tempCamera.y, x - tempCamera.x);
    tempCamera.angle = angle;
  }

  hoveredShopIndex = null;

  for(let i = 0; i < shops.length; i++){
    const shop = shops[i];
    const node = nodes[shop.node];
    
    // Check if shop is large
    const isLarge = node.size === "large";
    const hoverRadius = isLarge ? 75 : 60;

    if(Math.hypot(x - node.x, y - node.y) < hoverRadius){
      hoveredShopIndex = i;
      break;
    }
  }

});


/* ======================
   MOBILE SUPPORT
====================== */

// Pan state
let panX = 0, panY = 0;
let isPanning = false;
let panStartX = 0, panStartY = 0;
let panOriginX = 0, panOriginY = 0;

// Current mobile tab
let mobileTab = 'canvas';

function setMobileTab(tab){
  mobileTab = tab;
  const drawer = document.getElementById('mobileDrawer');
  const navBtns = document.querySelectorAll('#mobileNav button');

  // Update nav highlight
  navBtns.forEach(b => b.classList.remove('active'));
  const tabMap = { canvas: 0, controls: 1, analytics: 2 };
  if(navBtns[tabMap[tab]]) navBtns[tabMap[tab]].classList.add('active');

  if(tab === 'canvas'){
    drawer.classList.add('hidden');
    // Reset cursor state if we left mid-placement
  } else {
    drawer.classList.remove('hidden');
    buildMobileDrawer(tab);
  }
}

function buildMobileDrawer(tab){
  const el = document.getElementById('mobileDrawerContent');
  if(!el) return;

  if(tab === 'controls'){
    // Mirror: phase/wave info + CCTV + place guard/camera + shop controls
    const phase = gamePhase === 'planning' ? 'Planning' : 'Wave Active';
    const repMult = getRepSalaryMultiplier();
    const projSalary = getTotalSalaryPerSec() * waveLength;
    const multStr = repMult > 1.0 ? ` <span style="color:var(--neon-yellow)">(sec √ó${repMult.toFixed(2)})</span>` : '';

    // Threat intel lines
    let threatLines = '';
    if(flashMobKnowledge > 0) threatLines += `<div style="color:#ff9800;font-size:13px">‚ö° Flash Mob intel: ${flashMobKnowledge}/10</div>`;
    if(crewKnowledge > 0) threatLines += `<div style="color:#bf00ff;font-size:13px">üéØ Crew intel: ${crewKnowledge}/10 (${2+Math.floor(crewKnowledge/4)} operatives)</div>`;

    el.innerHTML = `
      <div style="display:flex;gap:8px;margin-bottom:10px;">
        <div style="flex:1;font-size:14px;">Wave <span style="color:var(--neon-yellow)">${waveNumber}</span> &nbsp;¬∑&nbsp; <span style="color:var(--neon-cyan)">${phase}</span></div>
        <div style="font-size:13px;color:var(--text-dim)">Est: ¬£${projSalary.toFixed(0)} salary${multStr}</div>
      </div>
      ${threatLines ? `<div style="padding:6px 8px;background:rgba(191,0,255,0.08);border:1px solid rgba(191,0,255,0.3);border-radius:4px;margin-bottom:8px;">${threatLines}</div>` : ''}
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px;">
        <button onclick="addGuard();setMobileTab('canvas')">Place Guard (¬£150)</button>
        <button onclick="addCamera();setMobileTab('canvas')" id="mPlaceCameraBtn">Place Camera (¬£50)</button>
      </div>
      <div id="mCCTVPanel" style="margin-bottom:8px;font-size:13px;"></div>
      <div id="mShopUnlockPanel" style="margin-bottom:8px;"></div>
      <div id="mShopControls"></div>
    `;

    // Mirror CCTV info
    const cctvSrc = document.getElementById('cctvPanel');
    const cctvDst = document.getElementById('mCCTVPanel');
    if(cctvSrc && cctvDst) cctvDst.innerHTML = cctvSrc.innerHTML;

    // Mirror shop unlock panel
    const unlockSrc = document.getElementById('shopUnlockPanel');
    const unlockDst = document.getElementById('mShopUnlockPanel');
    if(unlockSrc && unlockDst) unlockDst.innerHTML = unlockSrc.innerHTML;

    // Mirror shop controls
    const shopSrc = document.getElementById('shopControls');
    const shopDst = document.getElementById('mShopControls');
    if(shopSrc && shopDst) shopDst.innerHTML = shopSrc.innerHTML;

  } else if(tab === 'analytics'){
    // Mirror right panel analytics content
    const src = document.getElementById('analyticsPanel');
    const info = document.getElementById('infoPanel');
    const rules = document.getElementById('rulesPanel');
    el.innerHTML = `
      <div style="display:flex;gap:6px;margin-bottom:10px;">
        <button onclick="setRightMode('wave');buildMobileDrawer('analytics')" style="flex:1;padding:6px;font-size:13px;">Wave</button>
        <button onclick="setRightMode('info');buildMobileDrawer('analytics')" style="flex:1;padding:6px;font-size:13px;">Security</button>
        <button onclick="setRightMode('rules');buildMobileDrawer('analytics')" style="flex:1;padding:6px;font-size:13px;">Rules</button>
      </div>
      <div style="font-size:14px;">${src ? src.innerHTML : ''}</div>
      <div style="font-size:14px;${info && info.style.display!=='none' ? '' : 'display:none'}">${info ? info.innerHTML : ''}</div>
      <div style="font-size:14px;${rules && rules.style.display!=='none' ? '' : 'display:none'}">${rules ? rules.innerHTML : ''}</div>
    `;
  }
}

function updateMobileStats(){
  if(!isMobile()) return;
  const mMoney = document.getElementById('mMoney');
  const mRep = document.getElementById('mRep');
  const mVis = document.getElementById('mVisitors');
  const mBtn = document.getElementById('mStartWave');
  if(mMoney) mMoney.innerText = '¬£' + Math.round(money);
  if(mRep) mRep.innerText = Math.round(reputation);
  if(mVis) mVis.innerText = visitors.length;
  if(mBtn) mBtn.style.display = gamePhase === 'planning' ? '' : 'none';

  // Refresh drawer content live if open
  if(mobileTab !== 'canvas'){
    buildMobileDrawer(mobileTab);
  }
}

// ‚îÄ‚îÄ TOUCH EVENTS ON CANVAS ‚îÄ‚îÄ

let touchStartTime = 0;
let touchStartX = 0, touchStartY = 0;
let didDrag = false;

canvas.addEventListener('touchstart', function(e){
  e.preventDefault();
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  touchStartX = touch.clientX - rect.left;
  touchStartY = touch.clientY - rect.top;
  touchStartTime = Date.now();
  didDrag = false;

  // If in camera aiming step 2, start tracking drag for angle
  if(placingCamera && cameraPlacementStep === 2 && tempCamera){
    return; // handled in touchmove
  }

  // Start pan tracking
  isPanning = true;
  panStartX = touch.clientX;
  panStartY = touch.clientY;
  panOriginX = panX;
  panOriginY = panY;
}, { passive: false });

canvas.addEventListener('touchmove', function(e){
  e.preventDefault();
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const x = touch.clientX - rect.left;
  const y = touch.clientY - rect.top;

  const dx = touch.clientX - panStartX;
  const dy = touch.clientY - panStartY;

  if(Math.hypot(dx, dy) > 8) didDrag = true;

  // Camera aiming ‚Äî drag finger to aim
  if(placingCamera && cameraPlacementStep === 2 && tempCamera){
    const angle = Math.atan2(y - tempCamera.y, x - tempCamera.x);
    tempCamera.angle = angle;
    return;
  }

  // Pan the map
  if(isPanning){
    panX = panOriginX + dx;
    panY = panOriginY + dy;
  }
}, { passive: false });

canvas.addEventListener('touchend', function(e){
  e.preventDefault();
  isPanning = false;

  // Only treat as tap if short duration and no drag
  const elapsed = Date.now() - touchStartTime;
  if(elapsed < 300 && !didDrag){
    // Fire the same logic as a click at touchStartX/Y
    handleCanvasTap(touchStartX, touchStartY);
  }
}, { passive: false });

function handleCanvasTap(x, y){
  // Adjust for pan offset
  const ax = x - panX;
  const ay = y - panY;

  // Guard placement
  if(placingGuard && gamePhase === 'planning'){
    let patrolPath = calculateGuardPatrolPath(ax, ay);
    guards.push({ x: ax, y: ay, radius: 130, patrolPath, patrolProgress: 0, patrolDirection: 1 });
    cameras.forEach(c => c.synergyBonus = undefined);
    guards.forEach(g => g.synergyBonus = undefined);
    money -= 150;
    placingGuard = false;
    canvas.style.cursor = 'default';
    setMobileTab('controls');
    return;
  }

  // Camera placement step 1 ‚Äî place position
  if(placingCamera && gamePhase === 'planning' && cameraPlacementStep === 1){
    const snapped = snapCameraToWall(ax, ay);
    tempCamera = { x: snapped.x, y: snapped.y, angle: 0, range: 150, fov: Math.PI / 3 };
    cameraPlacementStep = 2;
    // Show instruction overlay briefly
    return;
  }

  // Camera placement step 2 ‚Äî confirm direction (tap anywhere to confirm current angle)
  if(placingCamera && gamePhase === 'planning' && cameraPlacementStep === 2){
    cameras.push(tempCamera);
    money -= 50;
    cameras.forEach(c => c.synergyBonus = undefined);
    guards.forEach(g => g.synergyBonus = undefined);
    buildCCTVUI(); updateCameraButton();
    placingCamera = false;
    cameraPlacementStep = 0;
    tempCamera = null;
    canvas.style.cursor = 'default';
    setMobileTab('controls');
    return;
  }

  // Shop selection
  for(let i = 0; i < shops.length; i++){
    const shop = shops[i];
    const node = nodes[shop.node];
    const isLarge = node.size === 'large';
    const tapRadius = isLarge ? 80 : 65;
    if(Math.hypot(ax - node.x, ay - node.y) < tapRadius){
      selectedShopIndex = i;
      buildSelectedShopUI();
      // Auto-open controls drawer to show shop options
      setMobileTab('controls');
      return;
    }
  }

  // Tap empty space ‚Äî deselect
  selectedShopIndex = null;
  buildSelectedShopUI();
}

// Pan is applied via ctx.save/translate at start of draw()

/* ======================
   VISITOR LOGIC
====================== */
/* ======================
   ORGANISED CRIME
====================== */

function spawnFlashMob(){
  flashMobKnowledge = Math.min(10, flashMobKnowledge + 1);
  
  // Pre-select single target: highest value with lowest hardening
  const scoredShops = shops
    .map(shop => {
      const node = nodes[shop.node];
      if(!node || node.unlocked === false) return null;
      const hardeningTier = shop.hardeningTier || 0;
      const score = shop.value * (1 + (3 - hardeningTier) * 0.8);
      return { shop, score };
    })
    .filter(Boolean)
    .sort((a, b) => b.score - a.score);
  
  const targetShop = scoredShops.length > 0 ? scoredShops[0].shop : null;
  const targetNode = targetShop ? targetShop.node : null;
  
  const mobSize = 8 + flashMobKnowledge + Math.floor(Math.random() * 5); // 8-12 ‚Üí 18-22 at max
  
  for(let i = 0; i < mobSize; i++){
    setTimeout(() => {
      if(gamePhase !== "wave") return;
      
      const spawnNode = i % 3 === 0 ? "entranceSide" : "entranceMain";
      
      visitors.push({
        x: nodes[spawnNode].x,
        y: nodes[spawnNode].y,
        currentNode: spawnNode,
        targetNode: "hub",
        spawnEntrance: spawnNode,
        plannedStops: 1,
        wantsFood: false,
        neverBuys: true,
        stopsVisited: 0,
        speed: 85,              // Fast - surge movement
        type: "opportunist",
        isFlashMob: true,
        flashMobTarget: targetNode,
        directRouting: true,    // Ignore all normal pathfinding logic
        knowledge: flashMobKnowledge,
        timeInMall: 0,
        baseS: 2,
        M: 55, S: 2, O: 20,
        R: 0,
        riskSensitivity: 0.05,  // Almost ignores risk entirely
        effortSensitivity: 1.5,
        theftsCommitted: 0,
        maxThefts: 4,
        visitedShops: {},
        visitedHub: false,
        finished: false,
        isFleeing: false,
        cameraMarks: {},
        finalDestination: null
      });
      
      waveStats.visitorTypes.opportunist = (waveStats.visitorTypes.opportunist || 0) + 1;
      waveStats.visitorTypes.flashmob = (waveStats.visitorTypes.flashmob || 0) + 1;
      
    }, i * 200);
  }
  
  const targetName = targetShop ? targetShop.name : "unknown";
  showEventNotification(`‚ö° Flash mob targeting ${targetName}! (Intel: ${flashMobKnowledge}/10)`, "#ff9800");
}

function scoreShopForCrew(shop){
  // Higher score = better target for the crew
  const node = nodes[shop.node];
  if(!node || node.unlocked === false) return -1;
  
  const hardeningTier = shop.hardeningTier || 0;
  const hasCamera = cameras.some(cam => Math.hypot(cam.x - node.x, cam.y - node.y) < cam.range);
  const guardsNearby = guards.some(g => Math.hypot(g.x - node.x, g.y - node.y) < g.radius + 60);
  
  let score = shop.value;                              // Base: shop value
  score *= (1 + (3 - hardeningTier) * 0.6);           // Hardening penalty (tier 3 = √ó1.0, tier 0 = √ó2.8)
  score *= hasCamera ? 0.4 : 1.0;                     // Camera halves score
  score *= guardsNearby ? 0.5 : 1.0;                  // Guards further reduce
  score *= 0.8 + (shop.rep / 250);                    // Rep bonus (worth more to hit)
  score *= 1 + (crewKnowledge * 0.05);                // Knowledge improves assessment accuracy
  
  return score;
}

function spawnCrewScout(){
  // Pre-entry: Score all unlocked shops and pick the best targets
  const maxCases = crewKnowledge >= 4 ? 4 : 3;       // Scout cases more shops as knowledge grows
  
  const scoredShops = shops
    .map((shop, i) => ({ shop, index: i, score: scoreShopForCrew(shop) }))
    .filter(s => s.score > 0)
    .sort((a, b) => b.score - a.score);
  
  // Only visit top N targets - ignore low-value or well-protected shops entirely
  const topTargets = scoredShops.slice(0, maxCases).map(s => s.shop.node);
  
  const spawnNode = Math.random() < 0.5 ? "entranceMain" : "entranceSide";
  
  const scout = {
    x: nodes[spawnNode].x,
    y: nodes[spawnNode].y,
    currentNode: spawnNode,
    targetNode: "hub",
    spawnEntrance: spawnNode,
    plannedStops: topTargets.length,  // Only visits pre-selected targets
    scoutTargets: topTargets,          // Pre-scored target list
    wantsFood: false,
    stopsVisited: 0,
    speed: 95,              // Fast - get in and out quickly
    type: "ordinary",       // Looks ordinary
    isScout: true,
    casedShops: [],
    timeInMall: 0,
    baseS: 30,
    M: 5, S: 30, O: 20,
    R: 0, theftsCommitted: 0,
    maxThefts: 0,
    visitedShops: {},
    visitedHub: false,
    finished: false,
    isFleeing: false,
    cameraMarks: {},
    finalDestination: null
  };
  
  visitors.push(scout);
  crewScoutActive = true;
  crewScoutId = scout;
  
  const topShopNames = scoredShops.slice(0, maxCases).map(s => s.shop.name).join(", ");
  showEventNotification(`üëÅ Suspicious individual casing the mall... (targeting: ${topShopNames})`, "#ff5722");
}

function spawnProfessionalCrew(){
  // Increment knowledge - crew gets smarter each appearance
  crewKnowledge = Math.min(10, crewKnowledge + 1);
  
  const crewSize = 2 + Math.floor(crewKnowledge / 4); // 2‚Üí3‚Üí4 at k4/k8
  const targets = crewScoutId?.casedShops || [];
  
  // Scout caught = crew is degraded (higher threshold, no blind-side bonus, less motivation)
  // Scout uncaught = full effectiveness + blind-side bonus
  const scoutCaught = crewScoutCaught;
  const blindSideBonus = scoutCaught ? 0 : 8;
  const crewThreshold = scoutCaught
    ? Math.max(28, 40 - (crewKnowledge * 1.0))   // Degraded: harder to steal
    : Math.max(20, 35 - (crewKnowledge * 1.5));   // Full: much easier to steal
  const crewMotivation = scoutCaught
    ? 38 + crewKnowledge                           // Degraded: lower motivation
    : 45 + crewKnowledge;                          // Full: high motivation
  
  for(let i = 0; i < crewSize; i++){
    const spawnNode = i % 2 === 0 ? "entranceMain" : "entranceSide";
    const assignedTarget = targets.length > 0 ? [targets[i % targets.length]] : [];
    
    visitors.push({
      x: nodes[spawnNode].x,
      y: nodes[spawnNode].y,
      currentNode: spawnNode,
      targetNode: "hub",
      spawnEntrance: spawnNode,
      plannedStops: 2 + Math.floor(crewKnowledge / 4),
      wantsFood: false,
      neverBuys: true,
      stopsVisited: 0,
      speed: 65,
      type: "specialist",
      isCrew: true,
      crewTargets: assignedTarget,
      knowledge: crewKnowledge,
      theftThreshold: crewThreshold,
      blindSideBonus: blindSideBonus,
      timeInMall: 0,
      baseS: 5,
      M: crewMotivation, S: 5, O: 20,
      R: blindSideBonus,
      riskSensitivity: 0.25,    // Very low risk sensitivity (professionals)
      effortSensitivity: 2.0,   // High effort (exploit every opportunity)
      theftsCommitted: 0,
      maxThefts: 2 + Math.floor(crewKnowledge / 3),
      visitedShops: {},
      visitedHub: false,
      finished: false,
      isFleeing: false,
      cameraMarks: {},
      finalDestination: null
    });
    
    waveStats.visitorTypes.crew = (waveStats.visitorTypes.crew || 0) + 1;
  }
  
  if(scoutCaught){
    showEventNotification(`‚ö†Ô∏è Crew entering - scout was flagged, operating degraded (Intel: ${crewKnowledge}/10)`, "#ff9800");
  } else {
    showEventNotification(`üö® Professional crew entering! Full intel, blind-side active (Intel: ${crewKnowledge}/10)`, "#f44336");
  }
  
  crewPending = false;
  crewScoutActive = false;
}

function showEventNotification(message, color){
  // Add floating notification on canvas
  floatingTexts.push({
    x: nodes.hub.x,
    y: nodes.hub.y - 60,
    text: message,
    color: color,
    life: 4.0,
    maxLife: 4.0,
    vy: -15,
    fontSize: 13,
    important: true
  });
}

function checkOrganisedCrime(dt){
  // === FLASH MOB ===
  // Wave 9+, Rep 45+
  // Roll ONCE at wave start (handled in startWave), timer-based arrival
  if(flashMobPending){
    flashMobTimer -= dt;
    if(flashMobTimer <= 0){
      flashMobPending = false;
      spawnFlashMob();
    }
  }
  
  // === PROFESSIONAL CREW ===
  // Wave 11+, Rep 65+
  // Scout spawns during peak traffic window (first 30% of wave)
  const inPeakTraffic = waveTimer > waveLength * 0.7;
  
  if(waveNumber >= 11 && reputation >= 65 && !crewScoutActive && !crewPending && !crewWarningShown && inPeakTraffic){
    // Roll once per frame but with correct probability for the window
    const crewChance = Math.min(0.8, 0.3 + (waveNumber - 11) * 0.05);
    // Spread across the peak traffic window frames
    const peakFrames = waveLength * 0.3 * 60;
    if(Math.random() < crewChance / peakFrames){
      crewWarningShown = true;
      spawnCrewScout();
    }
  }
  
  // Check if scout has finished casing the mall
  if(crewScoutActive && crewScoutId){
    const scout = crewScoutId;
    
    // Check if camera caught the scout
    // Base: 3 marks needed. Knowledge raises it further (max 5).
    // Busy mall also raises it - hard to isolate one face in a crowd.
    const crowdBonus = visitors.length > 30 ? 2 : visitors.length > 15 ? 1 : 0;
    const catchThreshold = Math.min(5, 3 + Math.floor(crewKnowledge / 4) + crowdBonus);
    const activeMarks = scout.cameraMarks 
      ? Object.keys(scout.cameraMarks).filter(k => !scout.cameraMarks[k].expired).length 
      : 0;
      
    if(activeMarks >= catchThreshold && !crewScoutCaught){
      crewScoutCaught = true;
      showEventNotification("üì∑ Suspicious individual flagged on camera - crew degraded!", "#ffaa00");
    }
    
    // Scout has left the mall
    if(scout.finished){
      crewScoutActive = false;
      crewPending = true;
      crewTimer = crewScoutCaught ? 0 : 12 + Math.random() * 8; // 12-20 seconds before crew arrives
    }
  }
  
  // Spawn crew after delay
  if(crewPending){
    crewTimer -= dt;
    if(crewTimer <= 0){
      spawnProfessionalCrew();
    }
  }
}

function spawnVisitor(){
  let type;
  const r = Math.random();

  // Opening Day & Progressive difficulty
  let ordinaryPct, opportunistPct, determinedPct, bigspenderPct, specialistPct;
  
  if(waveNumber === 1){
    // OPENING DAY: No determined criminals yet, word hasn't spread
    ordinaryPct = 70; 
    opportunistPct = 30; 
    determinedPct = 0;
    bigspenderPct = 0;
    specialistPct = 0;
  } else {
    // Base percentages from reputation (Wave 2+)
    // Smoother curve at low reputation to avoid death spiral
    if(reputation >= 80){
      ordinaryPct = 70; opportunistPct = 20; determinedPct = 3; bigspenderPct = 7; specialistPct = 0;
    } else if(reputation >= 70){
      ordinaryPct = 65; opportunistPct = 23; determinedPct = 5; bigspenderPct = 7; specialistPct = 0;
    } else if(reputation >= 50){
      ordinaryPct = 65; opportunistPct = 25; determinedPct = 10; bigspenderPct = 0; specialistPct = 0;
    } else if(reputation >= 30){
      ordinaryPct = 55; opportunistPct = 30; determinedPct = 15; bigspenderPct = 0; specialistPct = 0;
    } else if(reputation >= 15){
      ordinaryPct = 48; opportunistPct = 33; determinedPct = 19; bigspenderPct = 0; specialistPct = 0;
    } else {
      // Even at rock bottom (0-14 rep), not completely overrun
      ordinaryPct = 42; opportunistPct = 35; determinedPct = 23; bigspenderPct = 0; specialistPct = 0;
    }
    
    // Progressive wave difficulty: Sharper curve starting Wave 3
    // Reduce ordinary by 1% per wave, cap at -10%
    if(waveNumber >= 3){
      const waveDifficulty = Math.min(waveNumber - 2, 10); // Cap at wave 12
      ordinaryPct = Math.max(30, ordinaryPct - waveDifficulty);
      
      // Split the reduction between opportunist and determined
      const criminalIncrease = waveDifficulty;
      opportunistPct += criminalIncrease * 0.6;
      determinedPct += criminalIncrease * 0.4;
    }
    
    // SPECIALISTS appear when mall is successful enough to attract professional criminals
    // Requires both wave progression AND sufficient reputation
    if(waveNumber >= 6 && reputation >= 50){
      let specialistPercentage = 0;
      if(waveNumber >= 13 && reputation >= 70){
        specialistPercentage = 8; // Late game high-rep: 8% of mix
      } else if(waveNumber >= 9 && reputation >= 60){
        specialistPercentage = 5; // Mid-late game medium-rep: 5% of mix
      } else {
        specialistPercentage = 3; // Wave 6+ with rep 50+: 3% of mix
      }
      
      // Take from determined criminals (they "upgrade" to specialists)
      const reduction = Math.min(specialistPercentage, determinedPct);
      determinedPct -= reduction;
      specialistPct = reduction;
    }
  }
  
  // Normalize percentages
  const total = ordinaryPct + opportunistPct + determinedPct + bigspenderPct + specialistPct;
  ordinaryPct /= total;
  opportunistPct /= total;
  determinedPct /= total;
  bigspenderPct /= total;
  specialistPct /= total;
  
  // Select visitor type based on adjusted percentages
  const ordinaryThreshold = ordinaryPct;
  const opportunistThreshold = ordinaryPct + opportunistPct;
  const determinedThreshold = ordinaryPct + opportunistPct + determinedPct;
  const bigspenderThreshold = ordinaryPct + opportunistPct + determinedPct + bigspenderPct;
  
  if(r < ordinaryThreshold){
    type = "ordinary";
  } else if(r < opportunistThreshold){
    type = "opportunist";
  } else if(r < determinedThreshold){
    type = "determined";
  } else if(r < bigspenderThreshold){
    type = "bigspender";
  } else {
    type = "specialist";
  }
  
  waveStats.visitorTypes[type] = (waveStats.visitorTypes[type] || 0) + 1;
  
  const profiles = {
    ordinary:{ M:10, S:40, risk:1.5, effort:1.2, maxThefts:1, plannedStops:2 },
    opportunist:{ M:25, S:25, risk:1.0, effort:1.0, maxThefts:2, plannedStops:2 },
    determined:{ M:40, S:10, risk:0.5, effort:1.5, maxThefts:4, plannedStops:3 },
    bigspender:{ M:5, S:50, risk:2.0, effort:1.5, maxThefts:0, plannedStops:4 },  // Big spenders make multiple purchases
    specialist:{ M:45, S:5, risk:0.3, effort:2.0, maxThefts:3, plannedStops:4 }   // Professional thieves - ignore guardianship, resistant to cameras
  };

  const p = profiles[type];

  const spawnNode = Math.random() < 0.7 
    ? "entranceMain" 
    : "entranceSide";

  // Visit intent based on visitor type
  let plannedStops = p.plannedStops;
  const wantsFood = Math.random() < 0.3;

  visitors.push({
    x: nodes[spawnNode].x,
    y: nodes[spawnNode].y,

    currentNode: spawnNode,
    targetNode: "hub",
    
    spawnEntrance: spawnNode,
    plannedStops: plannedStops,
    wantsFood: wantsFood,
    stopsVisited: 0,
    
    speed: 60,
    type: type,
    timeInMall: 0,
    
    baseS: p.S,
    M: p.M,
    S: p.S,
    O: 20,
    R: 0,

    riskSensitivity: p.risk,
    effortSensitivity: p.effort,

    theftsCommitted: 0,
    maxThefts: p.maxThefts,
    purchasesMade: 0,  // Track purchases for big spenders

    visitedShops: {},
    finished: false
  });
}

/* ======================
   UPDATE
====================== */
function update(dt){
  // Track FPS
  frameCount++;
  fpsTimer += dt;
  if(fpsTimer >= 1.0){
    fps = frameCount;
    frameCount = 0;
    fpsTimer = 0;
  }
  
  if(gamePhase === "wave"){
    waveTimer -= dt;
    
    // Check for organised crime events
    checkOrganisedCrime(dt);

    // Spawn visitors in first 40% of wave (burst at beginning)
    if(waveTimer > waveLength * 0.6){      // Reputation-based spawn rate (balanced for 60fps)
      let spawnChance = 0.07; // Base rate (~50 visitors at 60fps)
      
      if(reputation >= 80){
        spawnChance = 0.10; // Very high (~72 visitors)
      } else if(reputation >= 70){
        spawnChance = 0.085; // High (~61 visitors)
      } else if(reputation >= 50){
        spawnChance = 0.07; // Normal (~50 visitors)
      } else if(reputation >= 20){
        spawnChance = 0.055; // Below average (~40 visitors)
      } else {
        spawnChance = 0.04; // Crisis (~29 visitors)
      }

      if(Math.random() < spawnChance) spawnVisitor();
    }

    // Animate guard patrols (linear back and forth)
    guards.forEach(g => {
      if(!g.patrolPath) return;
      
      // Update patrol progress (0 to 1 and back)
      g.patrolProgress = (g.patrolProgress || 0) + (g.patrolDirection || 1) * dt * 0.3;
      
      // Reverse direction at endpoints
      if(g.patrolProgress >= 1){
        g.patrolProgress = 1;
        g.patrolDirection = -1;
      } else if(g.patrolProgress <= 0){
        g.patrolProgress = 0;
        g.patrolDirection = 1;
      }
    });

    visitors.forEach(v=>{
      v.timeInMall = (v.timeInMall || 0) + dt;
      
      // Update camera marks (decay over time)
      if(v.cameraMarks){
        Object.keys(v.cameraMarks).forEach(cameraId => {
          const mark = v.cameraMarks[cameraId];
          if(!mark.expired){
            mark.timeLeft -= dt;
            if(mark.timeLeft <= 0){
              mark.expired = true;
            }
          }
        });
      }
      
      moveVisitor(v,dt);
      applySecurity(v);
      checkShops(v);
    });

    const salaryThisFrame = getTotalSalaryPerSec() * dt;
    money -= salaryThisFrame;
    waveStats.salaryPaid = (waveStats.salaryPaid || 0) + salaryThisFrame;

    visitors = visitors.filter(v => !v.finished);

    // Update visual effects
    floatingTexts.forEach(ft => {
      ft.life -= dt;
      ft.y += ft.vy * dt;
    });
    floatingTexts = floatingTexts.filter(ft => ft.life > 0);

    particles.forEach(p => {
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= 0.95; // friction
      p.vy *= 0.95;
    });
    particles = particles.filter(p => p.life > 0);

    preventionIndicators.forEach(pi => {
      pi.life -= dt;
    });
    preventionIndicators = preventionIndicators.filter(pi => pi.life > 0);

    // Wave ends when timer hits 0 AND all visitors have left
    if(waveTimer <= 0 && visitors.length === 0){
      endWave();
    }
  }
}

function moveVisitor(v, dt){
  let currentSpeed = v.speed * 1.15; // 15% global speed increase

  if(v.isFleeing){
    currentSpeed *= 1.3;
  }
  
  // Speed up remaining visitors when wave is nearly over (feels less draggy)
  if(visitors.length < 10){
    currentSpeed *= 1.55;
  } else if(visitors.length < 20){
    currentSpeed *= 1.40;
  }
  
  if(v.finished) return;

  const target = nodes[v.targetNode];

  const dx = target.x - v.x;
  const dy = target.y - v.y;
  const dist = Math.hypot(dx, dy);
  const step = currentSpeed * dt;

  // If close enough, snap to node
  if(dist <= step){
    v.x = target.x;
    v.y = target.y;
    v.currentNode = v.targetNode;
    
    // ‚úÖ Call the separate function here
    decideNextNode(v);

  } else {
    v.x += dx / dist * step;
    v.y += dy / dist * step;
  }
}

function decideNextNode(v){

  const current = nodes[v.currentNode];

  // EXIT CHECK
  if(
    (v.currentNode === "entranceMain" || v.currentNode === "entranceSide") &&
    v.visitedHub
  ){
    v.finished = true;
    return;
  }

  // FLASH MOB DIRECT ROUTING: Ignore all normal pathfinding
  // BFS straight to target, then exit. Runs before all other logic.
  if(v.directRouting && v.flashMobTarget){
    // Mark hub as visited so exit check works on return journey
    if(current.type === "decision") v.visitedHub = true;
    
    // Done visiting - head for exit
    if(v.stopsVisited >= v.plannedStops){
      if(current.type === "decision"){
        // At hub, pick nearest exit
        const distMain = Math.hypot(v.x - nodes.entranceMain.x, v.y - nodes.entranceMain.y);
        const distSide = Math.hypot(v.x - nodes.entranceSide.x, v.y - nodes.entranceSide.y);
        v.targetNode = distMain < distSide ? "entranceMain" : "entranceSide";
      } else {
        v.targetNode = findNextNodeToHub(v.currentNode);
      }
      return;
    }
    
    // Already at target - wait for checkShops to register the visit, then hub
    if(v.currentNode === v.flashMobTarget){
      v.targetNode = findNextNodeToHub(v.currentNode);
      return;
    }
    
    // Navigate toward target using BFS
    const nextStep = findPathNextStep(v.currentNode, v.flashMobTarget);
    if(nextStep){
      v.targetNode = nextStep;
    } else {
      // Fallback: can't find path, head to exit
      v.targetNode = findNextNodeToHub(v.currentNode);
    }
    return;
  }

  // FLEE CHECK
  if(v.timeInMall > 18 && v.theftsCommitted > 0){

    v.isFleeing = true;

    // If at hub ‚Üí choose nearest exit
    if(current.type === "decision"){
      const distMain = Math.hypot(v.x - nodes.entranceMain.x, v.y - nodes.entranceMain.y);
      const distSide = Math.hypot(v.x - nodes.entranceSide.x, v.y - nodes.entranceSide.y);
      v.targetNode = distMain < distSide ? "entranceMain" : "entranceSide";
      return;
    }

    // For any other node (shop, transit) - use BFS to find next step toward hub
    v.targetNode = findNextNodeToHub(v.currentNode);
    return;
  }


  // HUB LOGIC
  if(current.type === "decision"){
    v.visitedHub = true;

    // If still planning visits
    if(v.stopsVisited < v.plannedStops){

      // Get direct shop connections
      const directShopNodes = current.connections.filter(
        id => nodes[id].type === "shop" && (nodes[id].unlocked !== false)
      );
      
      // Check transit nodes for shops 1 level away
      const transitNodes = current.connections.filter(
        id => nodes[id].type === "transit" && (nodes[id].unlocked !== false)
      );
      
      const indirectShopNodes = [];
      
      // Level 1: Transit ‚Üí Shop
      transitNodes.forEach(transitId => {
        const transitNode = nodes[transitId];
        transitNode.connections.forEach(connId => {
          if(nodes[connId].type === "shop" && nodes[connId].unlocked !== false){
            indirectShopNodes.push(connId);
          }
        });
      });
      
      // Level 2: Shop ‚Üí Shop (e.g., wine shop ‚Üí luxury goods)
      const shopNodes1Level = current.connections.filter(
        id => nodes[id].type === "shop" && (nodes[id].unlocked !== false)
      );
      
      console.log(`Checking ${shopNodes1Level.length} shops connected to hub:`, shopNodes1Level);
      
      shopNodes1Level.forEach(shopId => {
        const shopNode = nodes[shopId];
        
        console.log(`  Checking shop ${shopId}, connections:`, shopNode.connections);
        
        shopNode.connections.forEach(connId => {
          if(nodes[connId].type === "shop" && nodes[connId].unlocked !== false && !directShopNodes.includes(connId)){
            console.log(`    Found shop beyond: ${connId}`);
            indirectShopNodes.push(connId);
          }
          // Also check for transit nodes beyond shops
          if(nodes[connId].type === "transit" && nodes[connId].unlocked !== false){
            console.log(`    Found transit: ${connId}, unlocked: ${nodes[connId].unlocked}`);
            const transitNode = nodes[connId];
            transitNode.connections.forEach(furtherConn => {
              if(nodes[furtherConn].type === "shop" && nodes[furtherConn].unlocked !== false){
                console.log(`      Found shop beyond transit: ${furtherConn}`);
                indirectShopNodes.push(furtherConn);
              }
              // Also check for MORE transit nodes beyond this one (eastJunction ‚Üí southJunction)
              if(nodes[furtherConn].type === "transit" && nodes[furtherConn].unlocked !== false){
                console.log(`      Found deeper transit: ${furtherConn}`);
                const deeperTransit = nodes[furtherConn];
                deeperTransit.connections.forEach(deepestConn => {
                  if(nodes[deepestConn].type === "shop" && nodes[deepestConn].unlocked !== false){
                    console.log(`        Found shop beyond deeper transit: ${deepestConn}`);
                    indirectShopNodes.push(deepestConn);
                  }
                });
              }
            });
          }
        });
      });
      
      const shopNodes = [...directShopNodes, ...indirectShopNodes];
      
      console.log(`Visitor at hub, discovered ${shopNodes.length} shops:`, shopNodes);
      console.log(`  Direct: ${directShopNodes.length}, Indirect: ${indirectShopNodes.length}`);

      // SCOUT: Only visit pre-selected target shops
      const availableShops = v.isScout
        ? shopNodes.filter(id => v.scoutTargets && v.scoutTargets.includes(id))
        : shopNodes;

      // Remove already visited shops
      const unvisited = availableShops.filter(nodeId=>{
        const idx = shops.findIndex(s => s.node === nodeId);
        return !v.visitedShops[idx];
      });

      const pickFrom = unvisited.length ? unvisited : availableShops;

      // === VALUE WEIGHTING ===
      const weighted = pickFrom.map(nodeId=>{
        const shop = shopByNode[nodeId];
        if(!shop) return { nodeId, weight: 1 };

        let weight = 1;

        // High value shops attract more browsing
        weight += shop.value / 40;

        // SMART TARGETING FOR DETERMINED THIEVES
        if(v.type === "determined"){
          const shopNode = nodes[nodeId];
          let vulnerability = shop.value / 20; // Base: higher value = more attractive
          
          // Check for guard coverage (major deterrent)
          let guardCoverage = false;
          guards.forEach(g => {
            const dist = Math.hypot(shopNode.x - g.x, shopNode.y - g.y);
            if(dist < g.radius){
              vulnerability -= 3; // Major penalty for guard
              guardCoverage = true;
            }
          });
          
          // Check for camera coverage
          cameras.forEach(cam => {
            const dx = shopNode.x - cam.x;
            const dy = shopNode.y - cam.y;
            const dist = Math.hypot(dx, dy);
            const angleToShop = Math.atan2(dy, dx);
            let angleDiff = angleToShop - cam.angle;
            while(angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while(angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            
            if(dist < cam.range && Math.abs(angleDiff) < cam.fov / 2){
              vulnerability -= 1.5; // Camera penalty
            }
          });
          
          // Bonus for profit-focused shops (higher opportunity)
          if(shop.strategy === "profit"){
            vulnerability += 2;
          }
          
          // Bonus for low shop reputation (appears poorly managed)
          if(shop.rep < 30){
            vulnerability += 1.5;
          }
          
          // Penalty for security-focused shops
          if(shop.strategy === "security"){
            vulnerability -= 1;
          }
          
          weight += Math.max(0, vulnerability);
        } 
        // SMART TARGETING FOR SPECIALISTS - Target known vulnerable shops
        else if(v.type === "specialist"){
          const shopNode = nodes[nodeId];
          let vulnerability = shop.value / 15; // Higher base attraction than determined
          
          // MAJOR BONUS: Low shop rep (word has spread in criminal network)
          if(shop.rep < 40){
            vulnerability += 3; // Strong attraction to vulnerable shops
          }
          if(shop.rep < 20){
            vulnerability += 3; // Extra bonus for very low rep (known easy target)
          }
          
          // Guards are still effective (physical presence)
          guards.forEach(g => {
            const dist = Math.hypot(shopNode.x - g.x, shopNode.y - g.y);
            if(dist < g.radius){
              vulnerability -= 2.5; // Moderate penalty (less than determined)
            }
          });
          
          // Cameras less effective (they study them)
          cameras.forEach(cam => {
            const dx = shopNode.x - cam.x;
            const dy = shopNode.y - cam.y;
            const dist = Math.hypot(dx, dy);
            const angleToShop = Math.atan2(dy, dx);
            let angleDiff = angleToShop - cam.angle;
            while(angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while(angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            
            if(dist < cam.range && Math.abs(angleDiff) < cam.fov / 2){
              vulnerability -= 0.75; // Half penalty vs determined
            }
          });
          
          // Target hardening is effective
          if(shop.strategy === "security" && shop.hardeningTier > 0){
            vulnerability -= 2;
          }
          
          weight += Math.max(0, vulnerability);
        }
        else {
          // Opportunists have slight value preference
          weight += shop.value / 25;
        }

        // If wants food, boost food court
        if(v.wantsFood && shop.name === "Food Court"){
          weight += 2;
        }

        // Reputation affects pull
        weight += shop.rep / 50;
        
        // FLASH MOB: Strongly converge on pre-selected target
        if(v.isFlashMob && v.flashMobTarget && v.flashMobTarget === nodeId){
          weight += 20; // Overwhelming pull toward target
        }
        
        // CREW: Heavily prioritise their assigned target shop
        if(v.isCrew && v.crewTargets && v.crewTargets.includes(nodeId)){
          weight += 15;
        }

        return { nodeId, weight };
      });

      let totalWeight = weighted.reduce((sum,s)=>sum+s.weight,0);
      let r = Math.random() * totalWeight;

      let chosen = weighted[0].nodeId;

      for(let item of weighted){
        r -= item.weight;
        if(r <= 0){
          chosen = item.nodeId;
          break;
        }
      }

      v.targetNode = chosen;
      
      const chosenShop = shops.find(s => s.node === chosen);
      console.log(`Visitor chose shop: ${chosenShop?.name || chosen}`);
      
      // Smart pathfinding: If chosen shop isn't directly connected, find the path
      if(!current.connections.includes(chosen)){
        console.log(`  Not directly connected, finding path...`);
        // Check if it's through a shop connection (e.g., hub ‚Üí wine shop ‚Üí luxury goods)
        for(let connId of current.connections){
          const connNode = nodes[connId];
          if(connNode.type === "shop" && connNode.unlocked !== false){
            // Check if this shop connects to our target directly
            if(connNode.connections.includes(chosen)){
              v.targetNode = connId; // Go to intermediate shop first
              v.finalDestination = chosen;
              console.log(`  Path: hub ‚Üí ${connId} (shop) ‚Üí ${chosen}`);
              break;
            }
            // Check if this shop connects to a transit that connects to target
            for(let furtherConn of connNode.connections){
              if(nodes[furtherConn].type === "transit" && nodes[furtherConn].unlocked !== false){
                if(nodes[furtherConn].connections.includes(chosen)){
                  v.targetNode = connId; // Go to intermediate shop
                  v.finalDestination = chosen;
                  console.log(`  Path: hub ‚Üí ${connId} (shop) ‚Üí ${furtherConn} (transit) ‚Üí ${chosen}`);
                  break;
                }
                // Check DEEPER: transit ‚Üí transit ‚Üí shop (eastJunction ‚Üí southJunction ‚Üí entertainment)
                for(let deeperConn of nodes[furtherConn].connections){
                  if(nodes[deeperConn].type === "transit" && nodes[deeperConn].unlocked !== false){
                    if(nodes[deeperConn].connections.includes(chosen)){
                      v.targetNode = connId; // Go to intermediate shop
                      v.finalDestination = chosen;
                      console.log(`  Path: hub ‚Üí ${connId} (shop) ‚Üí ${furtherConn} (transit) ‚Üí ${deeperConn} (transit) ‚Üí ${chosen}`);
                      break;
                    }
                  }
                }
              }
            }
          }
          // Check if it's through a transit node
          if(connNode.type === "transit" && connNode.unlocked !== false){
            if(connNode.connections.includes(chosen)){
              v.targetNode = connId; // Go to transit first
              v.finalDestination = chosen;
              break;
            }
          }
        }
      }
      
      return;
    }

    // If finished planned stops ‚Üí exit
    // When few visitors remain, head straight back to spawn entrance (fastest)
    if(visitors.length < 20){
      v.targetNode = v.spawnEntrance;
    } else {
      v.targetNode = Math.random() < 0.6
        ? v.spawnEntrance
        : (v.spawnEntrance === "entranceMain" ? "entranceSide" : "entranceMain");
    }

    return;
  }
  
  // SHOP NODE LOGIC - Continue to final destination or return
  if(current.type === "shop"){
    // If we have a final destination, continue navigating
    if(v.finalDestination){
      const finalNode = nodes[v.finalDestination];
      
      console.log(`At shop ${current.id}, heading to final destination: ${v.finalDestination}`);
      
      // Check if we can reach it directly from here
      if(current.connections.includes(v.finalDestination)){
        console.log(`  ‚Üí Direct connection found`);
        v.targetNode = v.finalDestination;
        v.finalDestination = null;
        return;
      }
      // Check if we need to go through a transit node
      for(let connId of current.connections){
        if(nodes[connId].type === "transit" && nodes[connId].unlocked !== false){
          const transitNode = nodes[connId];
          // Direct: transit ‚Üí shop
          if(transitNode.connections.includes(v.finalDestination)){
            console.log(`  ‚Üí Going through transit: ${connId}`);
            v.targetNode = connId;
            return;
          }
          // Deeper: transit ‚Üí transit ‚Üí shop (eastJunction ‚Üí southJunction ‚Üí entertainment)
          for(let deeperConn of transitNode.connections){
            if(nodes[deeperConn].type === "transit" && nodes[deeperConn].unlocked !== false){
              if(nodes[deeperConn].connections.includes(v.finalDestination)){
                console.log(`  ‚Üí Going through transit chain: ${connId} ‚Üí ${deeperConn}`);
                v.targetNode = connId; // Go to first transit
                return;
              }
            }
          }
        }
      }
      console.log(`  ‚Üí No path found, returning to hub`);
    }
    // Return to hub - find the correct next step
    v.targetNode = findNextNodeToHub(current.id);
    return;
  }
  
  // TRANSIT NODE LOGIC - Navigate through to final destination
  if(current.type === "transit"){
    // If we have a final destination, navigate towards it
    if(v.finalDestination){
      const finalNode = nodes[v.finalDestination];
      
      // Check if we can reach destination directly
      if(current.connections.includes(v.finalDestination)){
        v.targetNode = v.finalDestination;
        v.finalDestination = null;
        console.log(`At transit ${current.id}, going directly to ${v.targetNode}`);
        return;
      }
      
      // Check if we need to go through ANOTHER transit node (eastJunction ‚Üí southJunction)
      for(let connId of current.connections){
        if(nodes[connId].type === "transit" && nodes[connId].unlocked !== false){
          if(nodes[connId].connections.includes(v.finalDestination)){
            v.targetNode = connId;
            console.log(`At transit ${current.id}, continuing through transit ${connId}`);
            return;
          }
        }
      }
      
      console.log(`At transit ${current.id}, can't find path to ${v.finalDestination}, going to hub`);
      v.finalDestination = null;
    }
    // Return to hub via correct path
    v.targetNode = findNextNodeToHub(current.id);
    return;
  }

  // DEFAULT
  v.targetNode = "hub";
}


// BFS pathfinding - finds the first step from nodeId back to hub
function findNextNodeToHub(startId){
  if(startId === "hub") return "hub";
  
  // BFS
  const visited = new Set([startId]);
  const queue = [[startId, [startId]]];
  
  while(queue.length > 0){
    const [currentId, path] = queue.shift();
    const current = nodes[currentId];
    
    for(let connId of current.connections){
      if(visited.has(connId)) continue;
      visited.add(connId);
      
      const newPath = [...path, connId];
      
      if(connId === "hub"){
        return newPath[1];
      }
      
      const connNode = nodes[connId];
      if(connNode.unlocked !== false){
        queue.push([connId, newPath]);
      }
    }
  }
  
  console.warn(`findNextNodeToHub: no path found from ${startId} to hub`);
  return "hub";
}

// BFS from startId to targetId - returns the next step along the shortest path
function findPathNextStep(startId, targetId){
  if(startId === targetId) return targetId;
  
  const visited = new Set([startId]);
  const queue = [[startId, [startId]]];
  
  while(queue.length > 0){
    const [currentId, path] = queue.shift();
    const current = nodes[currentId];
    
    for(let connId of current.connections){
      if(visited.has(connId)) continue;
      visited.add(connId);
      
      const newPath = [...path, connId];
      
      if(connId === targetId){
        // Return first step after startId
        return newPath[1];
      }
      
      const connNode = nodes[connId];
      if(connNode && connNode.unlocked !== false){
        queue.push([connId, newPath]);
      }
    }
  }
  
  console.warn(`findPathNextStep: no path from ${startId} to ${targetId}`);
  return null;
}

function applySecurity(v){
  v.R = 0;
  v.S = v.baseS;
  
  // FLASH MOB: Completely ignores security - too fast and numerous to deter
  // Their riskSensitivity of 0.05 already makes R almost irrelevant,
  // but skip the calculations entirely for performance and clarity
  if(v.directRouting) return;

  guards.forEach(g=>{
    if(Math.hypot(v.x-g.x,v.y-g.y) < g.radius){
      // Use cached synergy bonus if available, otherwise calculate
      if(g.synergyBonus === undefined){
        let guardRisk = 20;  // Base guard risk
        
        // SYNERGY: Guard + Guardianship = "Active Protection"
        // Cache this calculation per guard
        shops.forEach((shop, idx) => {
          const node = nodes[shop.node];
          if(!node) return;
          const distToShop = Math.hypot(g.x - node.x, g.y - node.y);
          if(distToShop < 80 && shop.guardianshipTier > 0){
            guardRisk += 5; // Bonus risk when coordinating with staff
          }
        });
        
        g.synergyBonus = guardRisk; // Cache it
      }
      
      let appliedGuardRisk = g.synergyBonus;
      
      // OPPORTUNIST: Guards have limited attention in crowds
      if(v.type === "opportunist"){
        const visitorsNearGuard = visitors.filter(other => 
          Math.hypot(other.x - g.x, other.y - g.y) < g.radius
        ).length;
        
        const crowdPenalty = Math.max(0.3, 1 - (visitorsNearGuard / 20));
        appliedGuardRisk *= crowdPenalty;
      }
      
      // FLASH MOB: Guards massively overwhelmed, knowledge makes it worse
      // knowledge 0: 20% effective, knowledge 10: 5% effective
      if(v.isFlashMob){
        const knowledgeFactor = Math.max(0.05, 0.20 - (v.knowledge * 0.015));
        appliedGuardRisk *= knowledgeFactor;
      }
      
      // CREW: Know guard patrol patterns - knowledge reduces guard effectiveness
      // knowledge 0: 60% effective, knowledge 10: 25% effective
      if(v.isCrew){
        const knowledgeFactor = Math.max(0.25, 0.60 - (v.knowledge * 0.035));
        appliedGuardRisk *= knowledgeFactor;
      }
      
      v.R += appliedGuardRisk;
      v.S -= 5;
    }
  });

  // Camera effects - mark visitors when they cross cones (not continuous AoE)
  cameras.forEach(cam=>{
    const dx = v.x - cam.x;
    const dy = v.y - cam.y;
    const dist = Math.hypot(dx, dy);
    
    if(dist < cam.range){
      const angleToVisitor = Math.atan2(dy, dx);
      let angleDiff = angleToVisitor - cam.angle;
      
      // Normalize angle difference to -PI to PI
      while(angleDiff > Math.PI) angleDiff -= Math.PI * 2;
      while(angleDiff < -Math.PI) angleDiff += Math.PI * 2;
      
      // Check if within cone
      const inCone = Math.abs(angleDiff) < cam.fov / 2;
      
      if(inCone){
        // Mark visitor if not already marked by this camera recently
        const cameraId = `cam_${cam.x}_${cam.y}`;
        v.cameraMarks = v.cameraMarks || {};
        
        if(!v.cameraMarks[cameraId] || v.cameraMarks[cameraId].expired){
          // New detection - apply mark
          const numMarks = Object.keys(v.cameraMarks).filter(k => !v.cameraMarks[k].expired).length;
          
          // Escalating risk based on how many cameras have spotted them
          // Buffed to compensate for camera limits (4 base + CCTV unlocks)
          let markRisk = 12;  // First camera (was 8, +50%)
          if(numMarks >= 1) markRisk = 16;  // Second camera (was 12, +33%)
          if(numMarks >= 2) markRisk = 20;  // Third camera (was 15, +33%)
          if(numMarks >= 3) markRisk = 24;  // Fourth+ camera (was 18, +33%)
          
          // Apply CCTV level bonus (+2.5 per level, rounded down)
          markRisk += Math.floor(cctvLevel * 2.5);
          
          // Synergy: Camera + Target Hardening (cached)
          if(cam.synergyBonus === undefined){
            cam.synergyBonus = 0;
            shops.forEach((shop, idx) => {
              const node = nodes[shop.node];
              if(!node) return;
              const distToShop = Math.hypot(cam.x - node.x, cam.y - node.y);
              const angleToShop = Math.atan2(node.y - cam.y, node.x - cam.x);
              let shopAngleDiff = angleToShop - cam.angle;
              while(shopAngleDiff > Math.PI) shopAngleDiff -= Math.PI * 2;
              while(shopAngleDiff < -Math.PI) shopAngleDiff += Math.PI * 2;
              
              const shopInCone = distToShop < cam.range && Math.abs(shopAngleDiff) < cam.fov / 2;
              if(shopInCone && shop.hardeningTier > 0){
                cam.synergyBonus += 5; // Synergy bonus
              }
            });
          }
          
          markRisk += cam.synergyBonus;
          
          v.cameraMarks[cameraId] = {
            risk: markRisk,
            timeLeft: 10,  // Duration in seconds
            expired: false
          };
        }
      }
    }
  });
  
  // Apply all active camera marks
  if(v.cameraMarks){
    Object.keys(v.cameraMarks).forEach(cameraId => {
      const mark = v.cameraMarks[cameraId];
      if(!mark.expired){
        let appliedRisk = mark.risk;
        
        // SPECIALIST: Cameras 50% less effective (they study security systems)
        if(v.type === "specialist"){
          appliedRisk *= 0.5;
          // CREW: Additional resistance based on knowledge
          if(v.isCrew){
            const knowledgeFactor = Math.max(0.3, 1.0 - (v.knowledge * 0.07));
            appliedRisk *= knowledgeFactor;
          }
        }
        
        // SCOUT: Blends into crowd - cameras struggle to isolate them
        // In a busy mall, marks are diluted by crowd noise
        if(v.isScout){
          const crowdFactor = Math.min(visitors.length / 35, 0.85); // Up to 85% reduction
          appliedRisk *= (1 - crowdFactor);
          
          // In a crowd, marks take longer to confirm - reduce mark duration
          // so they expire before the threshold is reached
          const cameraId = Object.keys(v.cameraMarks).find(k => v.cameraMarks[k].risk === mark.risk);
          if(cameraId && visitors.length > 20){
            // Accelerate mark expiry in crowds (mark fades before flagging)
            v.cameraMarks[cameraId].timeLeft = Math.min(
              v.cameraMarks[cameraId].timeLeft,
              Math.max(2, 8 - visitors.length * 0.2) // Fewer seconds the busier it is
            );
          }
        }
        
        // OPPORTUNIST: Blend into crowds - cameras less effective when busy
        if(v.type === "opportunist"){
          const crowdFactor = Math.min(visitors.length / 30, 0.6);
          appliedRisk *= (1 - crowdFactor);
        }
        
        // FLASH MOB: Cameras barely effective - too many people to track
        // knowledge 0: 30% effective, knowledge 10: 8% effective
        if(v.isFlashMob){
          const knowledgeFactor = Math.max(0.08, 0.30 - (v.knowledge * 0.022));
          appliedRisk *= knowledgeFactor;
        }
        
        v.R += appliedRisk;
      }
    });
  }

  v.S = Math.max(0, v.S);
}

function checkShops(v){

  shops.forEach((shop, index)=>{

    // Skip if already visited
    if(v.visitedShops[index]) return;

    // Get node position for this shop
    const node = nodes[shop.node];

    // Detect proximity to node
    const interactionRadius = 60;

    if(Math.hypot(v.x - node.x, v.y - node.y) < interactionRadius){
    
      // FLASH MOB: Only register visit at their specific target shop, ignore all others
      if(v.directRouting && v.flashMobTarget && shop.node !== v.flashMobTarget){
        return;
      }
      
      v.visitedShops[index] = true; 
      v.stopsVisited++;
      
      // SCOUT: Case the shop - only pre-selected targets are visited
      if(v.isScout){
        // Record this shop as cased (all shops scout visits are targets)
        v.casedShops.push(shop.node);
        return; // Scout doesn't buy or steal - just observes and leaves
      }

      // Calculate effective opportunity and motivation
      let effectiveOpportunity = shop.baseOpportunity;
      let effectiveMotivation = v.M;
      
      // OPPORTUNIST: Emboldened by crowds - feel safer stealing when busy
      if(v.type === "opportunist"){
        const crowdBonus = Math.min(Math.floor(visitors.length / 10), 6); // Was /15, max 4
        effectiveMotivation += crowdBonus;
        // 20 visitors: +2 motivation
        // 30 visitors: +3 motivation
        // 40 visitors: +4 motivation
        // 50 visitors: +5 motivation
        // 60+ visitors: +6 motivation
      }

      // Apply profit model effects
      if(shop.strategy === "profit"){
        const track = storeUpgradeData[shop.type].profit;
        const measure = track[shop.profitTier];
        effectiveOpportunity += measure.oppDelta;
      }

      // Apply security model effects - BOTH branches can be active
      if(shop.strategy === "security"){
        // Apply target hardening effects
        if(shop.hardeningTier > 0){
          const hardeningTrack = storeUpgradeData[shop.type].security.targetHardening;
          const hardeningMeasure = hardeningTrack[shop.hardeningTier];
          effectiveOpportunity += hardeningMeasure.oppDelta;
        }
        
        // Apply guardianship effects
        // SPECIALIST: Completely ignores guardianship (professional training)
        if(shop.guardianshipTier > 0 && v.type !== "specialist"){
          const guardianTrack = storeUpgradeData[shop.type].security.guardianship;
          const guardianMeasure = guardianTrack[shop.guardianshipTier];
          effectiveMotivation += guardianMeasure.motDelta;
        }
      }

      v.O = effectiveOpportunity * v.effortSensitivity;

      // Calculate theft score
      const theftThreshold = v.theftThreshold || 35;
      const theftScore = effectiveMotivation + v.O - (v.R * v.riskSensitivity) + v.S;

      /* ======================
         THEFT
      ====================== */
      if(v.theftsCommitted < v.maxThefts && theftScore > theftThreshold){

        // THEFT VALUE MULTIPLIERS based on criminal type
        let theftMultiplier = 0.60;
        let shopRepDamage = 3;
        let mallRepDamage = waveNumber === 1 ? 1.5 : 2.0;
        
        if(v.isFlashMob){
          const hardeningTier = shop.hardeningTier || 0;
          const hardeningReduction = [1.0, 0.70, 0.40, 0.15];
          theftMultiplier = hardeningReduction[Math.min(hardeningTier, 3)];
          theftMultiplier = Math.min(1.0, theftMultiplier * (1 + v.knowledge * 0.04));
          
          // INCREASED: Visible chaos causes far more reputational damage
          if(hardeningTier >= 3){
            shopRepDamage = 4;     // Was 2 - even contained mobs are damaging
            mallRepDamage = 2.5;   // Was 1.0
          } else if(hardeningTier >= 2){
            shopRepDamage = 7;     // Was 4
            mallRepDamage = 4.0;   // Was 2.5
          } else if(hardeningTier >= 1){
            shopRepDamage = 9;     // Was 5
            mallRepDamage = 5.0;   // Was 3.0
          } else {
            shopRepDamage = 12;    // Was 7 - unprotected = catastrophic
            mallRepDamage = 6.0;   // Was 3.5
          }
          
          waveStats.theftsByType.flashmob = (waveStats.theftsByType.flashmob || 0) + 1;
        }
        else if(v.type === "specialist" || v.isCrew){
          theftMultiplier = 0.80;   // Was 0.75
          shopRepDamage = 8;        // Was 5 - word spreads fast in criminal networks
          mallRepDamage = 4.0;      // Was 2.0 - known target = major reputation hit
          if(v.isCrew){
            theftMultiplier = Math.min(1.0, 0.90 + (v.knowledge * 0.01));
            shopRepDamage = 8 + Math.floor(v.knowledge / 2);
            mallRepDamage = 4.0 + (v.knowledge * 0.3);
          }
        }
        else if(v.type === "opportunist"){
          const hasHardening = (shop.strategy === "security" && shop.hardeningTier > 0);
          const hasGuardianship = (shop.strategy === "security" && shop.guardianshipTier > 0);
          const hasUnlockedSecurityBranch = (shop.strategy === "profit" && shop.securityBranchUnlocked && shop.hardeningTier > 0);
          const hasAnySecurity = hasHardening || hasGuardianship || hasUnlockedSecurityBranch;
          
          if(hasAnySecurity){
            theftMultiplier = 0.35;
            shopRepDamage = 2;
          } else {
            theftMultiplier = 0.60;
            shopRepDamage = 3;
          }
        }
        
        // Apply shop reputation scaling to theft value
        // Low rep shops have less to steal, high rep shops are premium targets
        const reputationMultiplier = 0.6 + (shop.rep / 125);
        const theftLoss = shop.value * theftMultiplier * reputationMultiplier;

        money -= theftLoss;
        
        // Apply reputation loss - variable by criminal type
        reputation -= mallRepDamage;
        reputation = Math.max(0, reputation);

        waveStats.theftLoss += theftLoss;
        waveStats.thefts++;
        waveStats.theftsByType[v.type]++;
        waveStats.offenders.add(v);
        
        // Track financial loss by organised crime type
        if(v.isFlashMob){
          waveStats.flashMobLoss = (waveStats.flashMobLoss || 0) + theftLoss;
          waveStats.flashMobRepLoss = (waveStats.flashMobRepLoss || 0) + mallRepDamage;
        } else if(v.isCrew){
          waveStats.crewLoss = (waveStats.crewLoss || 0) + theftLoss;
          waveStats.crewRepLoss = (waveStats.crewRepLoss || 0) + mallRepDamage;
        }

        // Track shop-level theft data
        waveStats.shopThefts[index] = (waveStats.shopThefts[index] || 0) + 1;
        waveStats.shopLosses[index] = (waveStats.shopLosses[index] || 0) + theftLoss;

        shop.theftCount++;
        shop.rep -= shopRepDamage;  // Variable damage based on thief type
        shop.rep = Math.max(0, shop.rep);

        v.theftsCommitted++;

        // VISUAL EFFECTS - Theft
        const node = nodes[shop.node];
        floatingTexts.push({
          x: node.x,
          y: node.y,
          text: `-¬£${theftLoss.toFixed(0)}`,
          color: "#ff4444",
          life: 1.5,
          maxLife: 1.5,
          vy: -40
        });

        // Red particles for theft
        for(let i = 0; i < 8; i++){
          particles.push({
            x: node.x,
            y: node.y,
            vx: (Math.random() - 0.5) * 100,
            vy: (Math.random() - 0.5) * 100,
            life: 0.8,
            maxLife: 0.8,
            color: "#ff0000",
            size: 4
          });
        }
      }
      // Check if theft was PREVENTED (score close but not quite high enough)
      else if(v.theftsCommitted < v.maxThefts && theftScore > (theftThreshold - 10) && theftScore <= theftThreshold){
        // Theft was prevented by security!
        const node = nodes[shop.node];
        preventionIndicators.push({
          x: node.x,
          y: node.y - 40,
          icon: "üõ°Ô∏è",
          life: 1.5,
          maxLife: 1.5
        });
      }

      /* ======================
         LEGITIMATE PURCHASE
      ====================== */
      else if(v.S > effectiveMotivation && !v.neverBuys){

        let purchaseValue = shop.value + shop.revenueBonus;

        // Shop reputation affects revenue (natural balancing)
        // Formula: baseRevenue √ó (0.8 + shopRep/250)
        // Rep 50: 100% of base revenue
        // Rep 25: 90% of base revenue
        // Rep 75: 110% of base revenue
        const reputationMultiplier = 0.8 + (shop.rep / 250);
        const mallShare = purchaseValue * 0.35 * reputationMultiplier;

        money += mallShare;
        reputation += 0.3;  // Reduced from 1 to 0.3 (70% reduction)

        waveStats.mallRevenue += mallShare;
        shop.rep += 0.3;  // Reduced from 0.5 to 0.3 (40% reduction)
        shop.rep = Math.min(100, shop.rep);

        // Track purchases for big spenders
        if(v.type === "bigspender"){
          v.purchasesMade = (v.purchasesMade || 0) + 1;
        }

        // VISUAL EFFECTS - Purchase
        const node = nodes[shop.node];
        floatingTexts.push({
          x: node.x,
          y: node.y,
          text: `+¬£${mallShare.toFixed(0)}`,
          color: "#44ff44",
          life: 1.5,
          maxLife: 1.5,
          vy: -40
        });

        // Green particles for purchase
        for(let i = 0; i < 5; i++){
          particles.push({
            x: node.x,
            y: node.y,
            vx: (Math.random() - 0.5) * 80,
            vy: (Math.random() - 0.5) * 80,
            life: 0.6,
            maxLife: 0.6,
            color: "#00ff00",
            size: 3
          });
        }
      }

    }

  });

}

/* ======================
   DRAW
====================== */
// Helper: rounded rectangle path
function roundRect(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Apply pan offset on mobile
  ctx.save();
  if(isMobile()){
    ctx.translate(panX, panY);
  }

  // === VAPORWAVE BACKGROUND ===
  // Deep purple base
  const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
  bgGrad.addColorStop(0, '#0d0015');
  bgGrad.addColorStop(0.5, '#13002a');
  bgGrad.addColorStop(1, '#0a0010');
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Perspective grid lines (horizontal - converging toward horizon at canvas center)
  const horizon = canvas.height * 0.48;
  const cx = canvas.width / 2;
  ctx.strokeStyle = 'rgba(191,0,255,0.12)';
  ctx.lineWidth = 1;
  // Vertical (radiating from vanishing point)
  for(let i = 0; i <= 20; i++){
    const x = (canvas.width / 20) * i;
    ctx.beginPath();
    ctx.moveTo(cx + (x - cx) * 0.01, horizon);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }
  // Horizontal grid bands
  for(let i = 0; i < 10; i++){
    const y = horizon + (canvas.height - horizon) * (i / 9) * (i / 9);
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }

  // === CORRIDORS ===
  ctx.lineCap = "round";

  Object.values(nodes).forEach(node=>{
    node.connections.forEach(targetId=>{
      if(node.id < targetId){
        const target = nodes[targetId];
        
        const unlockablePaths = [
          ["hub", "wineshop"],
          ["wineshop", "northeastJunction"],
          ["northeastJunction", "luxurygoods"],
          ["eastJunction", "southJunction"],
          ["southJunction", "cinema"],
          ["southJunction", "bowling"],
          ["southJunction", "arcade"],
          ["southJunction", "foodcourt2"]
        ];
        
        const isUnlockablePath = unlockablePaths.some(path => 
          (path[0] === node.id && path[1] === targetId) ||
          (path[1] === node.id && path[0] === targetId)
        );
        
        const isLocked = (node.unlocked === false || target.unlocked === false);
        
        if(isUnlockablePath && isLocked){
          // Ghost corridors ‚Äî future paths
          ctx.strokeStyle = 'rgba(100,0,180,0.12)';
          ctx.lineWidth = 36;
          ctx.beginPath();
          ctx.moveTo(node.x, node.y);
          ctx.lineTo(target.x, target.y);
          ctx.stroke();
          return;
        }
        
        if(!isUnlockablePath && isLocked) return;

        // Active corridor: magenta/cyan two-tone
        // Outer glow
        ctx.strokeStyle = 'rgba(0,245,255,0.08)';
        ctx.lineWidth = 52;
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(target.x, target.y);
        ctx.stroke();

        // Mid fill
        ctx.strokeStyle = '#1a0035';
        ctx.lineWidth = 38;
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(target.x, target.y);
        ctx.stroke();

        // Edge lines (twin neon strips)
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(255,45,120,0.6)';
        ctx.beginPath();
        // offset lines along perpendicular
        const dx = target.x - node.x, dy = target.y - node.y;
        const len = Math.hypot(dx, dy);
        const nx = -dy/len * 19, ny = dx/len * 19;
        ctx.moveTo(node.x + nx, node.y + ny);
        ctx.lineTo(target.x + nx, target.y + ny);
        ctx.stroke();
        ctx.strokeStyle = 'rgba(0,245,255,0.6)';
        ctx.beginPath();
        ctx.moveTo(node.x - nx, node.y - ny);
        ctx.lineTo(target.x - nx, target.y - ny);
        ctx.stroke();
      }
    });
  });

  ctx.shadowBlur = 0;
  ctx.shadowColor = 'transparent';

  // === ENTRANCES ===
  // Main entrance
  ctx.shadowColor = '#00ff9f';
  ctx.shadowBlur = 20;
  ctx.fillStyle = '#003322';
  ctx.beginPath();
  ctx.arc(nodes.entranceMain.x, nodes.entranceMain.y, 35, 0, Math.PI*2);
  ctx.fill();
  ctx.strokeStyle = '#00ff9f';
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#00ff9f';
  ctx.font = "bold 13px 'Orbitron', sans-serif";
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText("MAIN", nodes.entranceMain.x, nodes.entranceMain.y);

  // Side entrance
  ctx.shadowColor = '#00f5ff';
  ctx.shadowBlur = 15;
  ctx.fillStyle = '#001a33';
  ctx.beginPath();
  ctx.arc(nodes.entranceSide.x, nodes.entranceSide.y, 28, 0, Math.PI*2);
  ctx.fill();
  ctx.strokeStyle = '#00f5ff';
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#00f5ff';
  ctx.font = "bold 11px 'Orbitron', sans-serif";
  ctx.fillText("SIDE", nodes.entranceSide.x, nodes.entranceSide.y);

  // === SHOPS ===
  ctx.font = "14px 'VT323', monospace";
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  shops.forEach((shop, i)=>{
    const node = nodes[shop.node];
    if(!node || (node.unlocked === false)) return;

    const isSelected = (i === selectedShopIndex);
    const isHovered = (i === hoveredShopIndex);

    const isLarge = node.size === 'large';
    const width = isLarge ? 150 : 100;
    const height = isLarge ? 90 : 60;

    // Color theme by strategy
    let fillInner, glowColor, borderColor, borderWidth = 2;

    if(shop.strategy === 'profit'){
      const t = Math.min(shop.profitTier / 3, 1);
      fillInner = `rgba(0,${40 + t*60},${40 + t*40},0.85)`;
      glowColor = '#00ff9f';
      borderColor = `rgba(0,255,159,${0.4 + t*0.5})`;
      borderWidth = 2 + shop.profitTier;
    } else if(shop.strategy === 'security'){
      const maxLevel = Math.max(shop.hardeningTier||0, shop.guardianshipTier||0);
      const t = Math.min(maxLevel / 3, 1);
      fillInner = `rgba(${20 + t*30},0,${60 + t*80},0.85)`;
      glowColor = '#bf00ff';
      borderColor = `rgba(191,0,255,${0.4 + t*0.5})`;
      borderWidth = 2 + maxLevel;
    } else {
      fillInner = 'rgba(20,0,40,0.85)';
      glowColor = '#8822cc';
      borderColor = 'rgba(100,0,180,0.5)';
    }

    if(isHovered){ fillInner = 'rgba(40,0,70,0.9)'; glowColor = '#ff2d78'; borderColor = '#ff2d78'; }
    if(isSelected){ fillInner = 'rgba(60,0,90,0.95)'; glowColor = '#00f5ff'; borderColor = '#00f5ff'; borderWidth = 3; }

    // Crime heat
    if(shop.theftCount > 0){
      const intensity = Math.min(shop.theftCount * 6, 35);
      ctx.shadowColor = '#ff2d78';
      ctx.shadowBlur = intensity;
    } else {
      ctx.shadowColor = glowColor;
      ctx.shadowBlur = isSelected || isHovered ? 20 : 8;
    }

    // Shop fill
    ctx.fillStyle = fillInner;
    ctx.beginPath();
    roundRect(ctx, node.x - width/2, node.y - height/2, width, height, 4);
    ctx.fill();
    ctx.shadowBlur = 0;

    // Border
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = borderWidth;
    ctx.beginPath();
    roundRect(ctx, node.x - width/2, node.y - height/2, width, height, 4);
    ctx.stroke();

    // Selection outer glow ring
    if(isSelected){
      ctx.strokeStyle = 'rgba(0,245,255,0.3)';
      ctx.lineWidth = 8;
      ctx.beginPath();
      roundRect(ctx, node.x - width/2 - 6, node.y - height/2 - 6, width+12, height+12, 6);
      ctx.stroke();
    }

    // Upgrade indicators
    ctx.fillStyle = '#fff';
    ctx.font = "12px 'VT323', monospace";
    ctx.textAlign = 'left';
    if(shop.hardeningTier > 0) ctx.fillText("üîí", node.x - width/2 + 5, node.y - height/2 + 15);
    if(shop.guardianshipTier > 0) ctx.fillText("üõ°", node.x - width/2 + 5, node.y - height/2 + 30);
    if(shop.securityBranchUnlocked) ctx.fillText("üîê", node.x - width/2 + 20, node.y - height/2 + 15);

    // Shop rep bar (bottom of shop)
    const barW = width - 10;
    const barX = node.x - barW/2;
    const barY = node.y + height/2 - 8;
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(barX, barY, barW, 4);
    const repFill = Math.max(0, Math.min(shop.rep / 100, 1));
    const repColor = repFill > 0.6 ? '#00ff9f' : repFill > 0.3 ? '#ffe600' : '#ff2d78';
    ctx.fillStyle = repColor;
    ctx.fillRect(barX, barY, barW * repFill, 4);

    // Shop name
    ctx.fillStyle = isSelected ? '#00f5ff' : '#e8d5ff';
    ctx.font = "14px 'VT323', monospace";
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const nameY = shop.hardeningTier > 0 ? node.y - 4 : node.y;
    ctx.fillText(shop.name, node.x, nameY);
  });

  // Hub node
  ctx.shadowColor = '#ff2d78';
  ctx.shadowBlur = 25;
  const hubGrad = ctx.createRadialGradient(nodes.hub.x, nodes.hub.y, 5, nodes.hub.x, nodes.hub.y, 30);
  hubGrad.addColorStop(0, 'rgba(255,45,120,0.4)');
  hubGrad.addColorStop(1, 'rgba(80,0,60,0.1)');
  ctx.fillStyle = hubGrad;
  ctx.beginPath();
  ctx.arc(nodes.hub.x, nodes.hub.y, 30, 0, Math.PI*2);
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,45,120,0.6)';
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.shadowBlur = 0;
  ctx.fillStyle = 'rgba(255,45,120,0.8)';
  ctx.font = "bold 11px 'Orbitron', sans-serif";
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText("HUB", nodes.hub.x, nodes.hub.y);

  // === GUARDS ===
  guards.forEach(g=>{
    ctx.strokeStyle = 'rgba(0,245,255,0.12)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(g.x, g.y, g.radius, 0, Math.PI*2);
    ctx.stroke();

    ctx.shadowColor = '#00f5ff';
    ctx.shadowBlur = 10;
    ctx.fillStyle = '#003344';
    ctx.beginPath();
    ctx.arc(g.x, g.y, 8, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#00f5ff';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.shadowBlur = 0;

    if(gamePhase === 'wave' && g.patrolPath){
      const t = g.patrolProgress || 0;
      const patrolX = g.patrolPath.startX + (g.patrolPath.endX - g.patrolPath.startX) * t;
      const patrolY = g.patrolPath.startY + (g.patrolPath.endY - g.patrolPath.startY) * t;
      ctx.strokeStyle = 'rgba(0,200,255,0.2)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4,6]);
      ctx.beginPath();
      ctx.moveTo(g.patrolPath.startX, g.patrolPath.startY);
      ctx.lineTo(g.patrolPath.endX, g.patrolPath.endY);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.shadowColor = '#00f5ff';
      ctx.shadowBlur = 14;
      ctx.fillStyle = '#00ccff';
      ctx.beginPath();
      ctx.arc(patrolX, patrolY, 7, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  });

  // === CAMERAS ===
  cameras.forEach(cam=>{
    ctx.fillStyle = 'rgba(255,45,120,0.05)';
    ctx.strokeStyle = 'rgba(255,45,120,0.25)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cam.x, cam.y);
    ctx.arc(cam.x, cam.y, cam.range, cam.angle - cam.fov/2, cam.angle + cam.fov/2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.shadowColor = '#ff2d78';
    ctx.shadowBlur = 8;
    ctx.fillStyle = '#330011';
    ctx.beginPath();
    ctx.arc(cam.x, cam.y, 5, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#ff2d78';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.shadowBlur = 0;
    ctx.strokeStyle = 'rgba(255,45,120,0.7)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(cam.x, cam.y);
    ctx.lineTo(cam.x + Math.cos(cam.angle)*12, cam.y + Math.sin(cam.angle)*12);
    ctx.stroke();
  });

  if(tempCamera && cameraPlacementStep === 2){
    ctx.fillStyle = 'rgba(255,45,120,0.2)';
    ctx.strokeStyle = 'rgba(255,45,120,0.7)';
    ctx.lineWidth = 1;
    ctx.setLineDash([4,4]);
    ctx.beginPath();
    ctx.moveTo(tempCamera.x, tempCamera.y);
    ctx.arc(tempCamera.x, tempCamera.y, tempCamera.range, tempCamera.angle - tempCamera.fov/2, tempCamera.angle + tempCamera.fov/2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.shadowColor = '#ff2d78';
    ctx.shadowBlur = 12;
    ctx.fillStyle = '#ff2d78';
    ctx.beginPath();
    ctx.arc(tempCamera.x, tempCamera.y, 7, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.strokeStyle = '#ffaacc';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(tempCamera.x, tempCamera.y);
    ctx.lineTo(tempCamera.x + Math.cos(tempCamera.angle)*18, tempCamera.y + Math.sin(tempCamera.angle)*18);
    ctx.stroke();
    ctx.fillStyle = '#ff2d78';
    ctx.font = "14px 'VT323', monospace";
    ctx.textAlign = 'center';
    ctx.fillText('CLICK TO AIM CAMERA', tempCamera.x, tempCamera.y - 170);
  }



  visitors.forEach(v => {
    const t = Date.now();

    if(v.isFleeing){
      // Fleeing - hot white/cyan burst
      ctx.shadowColor = '#ffffff';
      ctx.shadowBlur = 14;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(v.x, v.y, 7, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    else if(v.isScout){
      if(crewScoutCaught){
        ctx.shadowColor = '#ff2d78';
        ctx.shadowBlur = 16;
        ctx.fillStyle = '#ff2d78';
        ctx.beginPath();
        ctx.arc(v.x, v.y, 7, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#fff';
        ctx.font = "10px sans-serif";
        ctx.textAlign = 'center';
        ctx.fillText("üëÅ", v.x, v.y - 13);
      } else {
        // Blends in ‚Äî looks like ordinary visitor
        ctx.fillStyle = 'rgba(180,150,255,0.85)';
        ctx.beginPath();
        ctx.arc(v.x, v.y, 6, 0, Math.PI*2);
        ctx.fill();
      }
    }
    else if(v.isCrew){
      // Professional crew ‚Äî deep magenta pulse
      const pulse = 10 + Math.sin(t / 120) * 3;
      ctx.shadowColor = '#ff00cc';
      ctx.shadowBlur = 20;
      ctx.fillStyle = '#cc00aa';
      ctx.beginPath();
      ctx.arc(v.x, v.y, pulse, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = '#ff44ee';
      ctx.lineWidth = 1.5;
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    else if(v.isFlashMob){
      // Flash mob ‚Äî hot neon yellow/orange surge
      const pulse = 8 + Math.sin(t / 80 + v.x) * 2;
      ctx.shadowColor = '#ffe600';
      ctx.shadowBlur = 12;
      ctx.fillStyle = '#ffaa00';
      ctx.beginPath();
      ctx.arc(v.x, v.y, pulse, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    else if(v.type === 'specialist'){
      // Lone specialist ‚Äî crimson pulsing threat
      const pulse = 11 + Math.sin(t / 180) * 2;
      ctx.shadowColor = '#ff0044';
      ctx.shadowBlur = 18;
      ctx.fillStyle = '#cc0033';
      ctx.beginPath();
      ctx.arc(v.x, v.y, pulse, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = '#ff3366';
      ctx.lineWidth = 1.5;
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    else if(v.type === 'bigspender'){
      // Big spender ‚Äî gold shimmer
      ctx.shadowColor = '#ffe600';
      ctx.shadowBlur = 14;
      ctx.fillStyle = '#ccaa00';
      ctx.beginPath();
      ctx.arc(v.x, v.y, 9, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = '#ffe600';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    else if(v.type === 'ordinary'){
      // Ordinary visitor ‚Äî soft teal
      ctx.fillStyle = 'rgba(0,220,200,0.75)';
      ctx.beginPath();
      ctx.arc(v.x, v.y, 6, 0, Math.PI*2);
      ctx.fill();
    }
    else if(v.type === 'opportunist'){
      // Opportunist ‚Äî warm amber
      ctx.fillStyle = 'rgba(255,180,0,0.8)';
      ctx.beginPath();
      ctx.arc(v.x, v.y, 6, 0, Math.PI*2);
      ctx.fill();
    }
    else if(v.type === 'determined'){
      // Determined ‚Äî orange-red
      ctx.fillStyle = 'rgba(255,80,30,0.85)';
      ctx.beginPath();
      ctx.arc(v.x, v.y, 7, 0, Math.PI*2);
      ctx.fill();
    }
    else {
      ctx.fillStyle = 'rgba(150,100,200,0.7)';
      ctx.beginPath();
      ctx.arc(v.x, v.y, 6, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.shadowBlur = 0;
  });

  // Draw particles
  particles.forEach(p => {
    const alpha = p.life / p.maxLife;
    ctx.fillStyle = p.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
    ctx.fill();
  });

  // Draw floating text
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  floatingTexts.forEach(ft => {
    const alpha = ft.life / ft.maxLife;
    const hexAlpha = Math.floor(alpha * 255).toString(16).padStart(2, '0');
    const size = ft.important ? 15 : 14;
    ctx.font = `bold ${size}px 'Orbitron', sans-serif`;
    ctx.shadowColor = ft.color;
    ctx.shadowBlur = ft.important ? 14 : 6;
    ctx.fillStyle = ft.color + hexAlpha;
    ctx.fillText(ft.text, ft.x, ft.y);
    ctx.shadowBlur = 0;
  });

  // Draw prevention indicators
  ctx.font = "bold 30px Arial";
  preventionIndicators.forEach(pi => {
    const alpha = pi.life / pi.maxLife;
    const scale = 1 + (1 - alpha) * 0.5;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.shadowColor = '#00f5ff';
    ctx.shadowBlur = 12;
    ctx.translate(pi.x, pi.y);
    ctx.scale(scale, scale);
    ctx.fillText(pi.icon, 0, 0);
    ctx.restore();
    ctx.shadowBlur = 0;
  });

  // Restore pan transform
  ctx.restore();

  // Mobile placement hints (drawn outside pan transform)
  if(isMobile()){
    if(placingGuard){
      ctx.fillStyle = 'rgba(13,0,21,0.85)';
      ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
      ctx.fillStyle = '#00f5ff';
      ctx.font = "bold 13px 'Orbitron', sans-serif";
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('TAP MAP TO PLACE GUARD', canvas.width/2, canvas.height - 25);
    } else if(placingCamera && cameraPlacementStep === 1){
      ctx.fillStyle = 'rgba(13,0,21,0.85)';
      ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
      ctx.fillStyle = '#ff2d78';
      ctx.font = "bold 13px 'Orbitron', sans-serif";
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('TAP MAP TO PLACE CAMERA', canvas.width/2, canvas.height - 25);
    } else if(placingCamera && cameraPlacementStep === 2){
      ctx.fillStyle = 'rgba(13,0,21,0.85)';
      ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
      ctx.fillStyle = '#ff2d78';
      ctx.font = "bold 13px 'Orbitron', sans-serif";
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('DRAG TO AIM ¬∑ TAP TO CONFIRM', canvas.width/2, canvas.height - 25);
    }
  }

  document.getElementById("money").innerText = Math.round(money);
  document.getElementById("rep").innerText = Math.round(reputation);
  
  // Update reputation tier display with color
  const repTierEl = document.getElementById("repTier");
  if(reputation >= 80){
    repTierEl.innerText = "(Thriving)";
    repTierEl.style.color = "#4caf50";
  } else if(reputation >= 70){
    repTierEl.innerText = "(Excellent)";
    repTierEl.style.color = "#8bc34a";
  } else if(reputation >= 50){
    repTierEl.innerText = "(Stable)";
    repTierEl.style.color = "#ffc107";
  } else if(reputation >= 30){
    // Wave 1: "Just Opened!" instead of "Unpopular"
    repTierEl.innerText = waveNumber === 1 ? "(Just Opened!)" : "(Unpopular)";
    repTierEl.style.color = "#ff9800";
  } else if(reputation >= 15){
    repTierEl.innerText = waveNumber === 1 ? "(Just Opened!)" : "(Struggling)";
    repTierEl.style.color = "#ff5722";
  } else {
    repTierEl.innerText = waveNumber === 1 ? "(Just Opened!)" : "(Crisis)";
    repTierEl.style.color = "#f44336";
  }
  
  document.getElementById("visitors").innerText = visitors.length;
  document.getElementById("phaseDisplay").innerText =
    gamePhase === "planning" ? "Planning" : "Wave Active";

  const shopSalary = getShopSalaryPerSec();
  const securitySalary = (getGuardSalaryPerSec() + getCCTVSalaryPerSec()) * getRepSalaryMultiplier();
  const totalSalary = (gamePhase === "wave") ? getTotalSalaryPerSec() : 0;
  const repMult = getRepSalaryMultiplier();
  const salaryText = repMult > 1.0
    ? `${totalSalary.toFixed(1)}/sec (sec √ó${repMult.toFixed(2)})`
    : totalSalary.toFixed(1) + "/sec";
  document.getElementById("salaryDisplay").innerText = salaryText;

  // Salary forecast (planning phase)
  const forecastEl = document.getElementById("salaryForecastPanel");
  if(forecastEl){
    const projectedSalary = getTotalSalaryPerSec() * waveLength;
    const secBase = getGuardSalaryPerSec() + getCCTVSalaryPerSec();
    const shopBase = getShopSalaryPerSec();
    if(secBase > 0 || shopBase > 0){
      const multStr = repMult > 1.0 ? ` <span style="color:#ff9800">(sec √ó${repMult.toFixed(2)})</span>` : "";
      forecastEl.innerHTML = `Est. wave salary: ¬£${projectedSalary.toFixed(0)}${multStr}`;
    } else {
      forecastEl.innerHTML = "";
    }
  }

  // Threat intel (planning phase - show known threat levels)
  const threatEl = document.getElementById("threatIntelPanel");
  if(threatEl){
    const lines = [];
    if(flashMobKnowledge > 0){
      lines.push(`<span style="color:#ff9800">‚ö° Flash Mob intel: ${flashMobKnowledge}/10</span>`);
    }
    if(crewKnowledge > 0){
      const crewSizeNext = 2 + Math.floor(crewKnowledge / 4);
      lines.push(`<span style="color:#9c27b0">üéØ Crew intel: ${crewKnowledge}/10 (${crewSizeNext} operatives)</span>`);
    }
    if(lines.length > 0){
      threatEl.style.display = "block";
      threatEl.innerHTML = "<b>‚ö† Threat Intel</b><br>" + lines.join("<br>");
    } else {
      threatEl.style.display = "none";
    }
  }

  // Right panel: wave view updates live (only if wave tab selected or wave mode visible)
  if(gamePhase === "wave" || (gamePhase === "planning" && waveStats.mallRevenue > 0)){
    const net = waveStats.mallRevenue - waveStats.theftLoss - waveStats.salaryPaid;

    let netColor = "#aaa";
    if(net > 0) netColor = "#4caf50";
    else if(net < 0) netColor = "#e53935";

    // Build shop theft breakdown
    let shopTheftBreakdown = "";
    const shopTheftEntries = Object.entries(waveStats.shopThefts)
      .map(([idx, count]) => ({
        index: parseInt(idx),
        name: shops[idx].name,
        count: count,
        loss: waveStats.shopLosses[idx] || 0
      }))
      .sort((a, b) => b.count - a.count); // Sort by theft count descending

    if(shopTheftEntries.length > 0){
      shopTheftBreakdown = "<b>Thefts by Shop</b><br>";
      shopTheftEntries.forEach(entry => {
        shopTheftBreakdown += `${entry.name}: ${entry.count} (¬£${entry.loss.toFixed(0)})<br>`;
      });
      shopTheftBreakdown += "<br>";
    }

    const phaseLabel = gamePhase === "planning" ? "Previous Wave Results" : "Current Wave";

    document.getElementById("analyticsPanel").innerHTML = `
      <b>${phaseLabel}</b><br><br>
      <b>Revenue</b><br>
      Mall Revenue: ¬£${waveStats.mallRevenue.toFixed(0)}<br><br>

      <b>Costs</b><br>
      ${(() => {
        const shopS = getShopSalaryPerSec();
        const secS = (getGuardSalaryPerSec() + getCCTVSalaryPerSec()) * getRepSalaryMultiplier();
        const mult = getRepSalaryMultiplier();
        const secStr = mult > 1.0
          ? `¬£${(secS * waveLength).toFixed(0)} <span class="muted">(√ó${mult.toFixed(2)} rep)</span>`
          : `¬£${(secS * waveLength).toFixed(0)}`;
        return `Salary: ¬£${waveStats.salaryPaid.toFixed(0)}<br>
        <span class="muted" style="font-size:10px">
          Staff: ¬£${(shopS * waveLength).toFixed(0)} ¬∑ Security: ${secStr}
        </span>`;
      })()}<br>
      Theft Loss: ¬£${waveStats.theftLoss.toFixed(0)}<br><br>

      <b>Crime</b><br>
      Thefts: ${waveStats.thefts} &nbsp;|&nbsp; Offenders: ${waveStats.offenders.size}<br>
      <br>

      ${(waveStats.visitorTypes.flashmob > 0 || waveStats.visitorTypes.crew > 0) ? `
      <b>‚ö† Organised Crime</b><br>
      ${waveStats.visitorTypes.flashmob > 0 ? `
        <span style="color:#ff9800">‚ö° Flash Mob</span>
        &nbsp;(Intel: ${flashMobKnowledge}/10)<br>
        &nbsp;Members: ${waveStats.visitorTypes.flashmob}
        &nbsp;|&nbsp; Thefts: ${waveStats.theftsByType.flashmob || 0}<br>
        ${waveStats.flashMobLoss > 0 ? `&nbsp;Loss: <span style="color:#ff6666">¬£${(waveStats.flashMobLoss||0).toFixed(0)}</span>
        &nbsp;|&nbsp; Rep: <span style="color:#ff6666">-${(waveStats.flashMobRepLoss||0).toFixed(1)}</span><br>` : ''}
        <br>
      ` : ''}
      ${waveStats.visitorTypes.crew > 0 ? `
        <span style="color:#9c27b0">üéØ Professional Crew</span>
        &nbsp;(Intel: ${crewKnowledge}/10)<br>
        &nbsp;Members: ${waveStats.visitorTypes.crew}
        &nbsp;|&nbsp; Thefts: ${waveStats.theftsByType.crew || 0}<br>
        ${waveStats.crewLoss > 0 ? `&nbsp;Loss: <span style="color:#ff6666">¬£${(waveStats.crewLoss||0).toFixed(0)}</span>
        &nbsp;|&nbsp; Rep: <span style="color:#ff6666">-${(waveStats.crewRepLoss||0).toFixed(1)}</span><br>` : ''}
        &nbsp;Scout: ${crewScoutCaught ? '<span style="color:#44ff44">Flagged (crew degraded)</span>' : '<span style="color:#ff4444">Uncaught (full intel)</span>'}<br>
        <br>
      ` : ''}
      ` : ''}

      <b>Visitors</b><br>
      Ordinary: ${waveStats.visitorTypes.ordinary}
      &nbsp;|&nbsp; Big Spenders: ${waveStats.visitorTypes.bigspender || 0}<br>
      Opportunist: ${waveStats.visitorTypes.opportunist}
      &nbsp;|&nbsp; Determined: ${waveStats.visitorTypes.determined}<br>
      ${waveStats.visitorTypes.specialist > 0 ? `Specialists: ${waveStats.visitorTypes.specialist}<br>` : ''}
      <br>

      <b>Thefts by type</b><br>
      Ordinary: ${waveStats.theftsByType.ordinary || 0}
      &nbsp;|&nbsp; Opportunist: ${waveStats.theftsByType.opportunist || 0}<br>
      Determined: ${waveStats.theftsByType.determined || 0}
      ${waveStats.theftsByType.specialist > 0 ? `&nbsp;|&nbsp; Specialists: ${waveStats.theftsByType.specialist}` : ''}<br>
      <br>

      ${shopTheftBreakdown}

      <div style="font-size:16px; color:${netColor}">
        Net: ¬£${net.toFixed(0)}
      </div>
      
      <br><b>Reputation</b><br>
      ${(() => {
        const repEnd = reputation;
        const repChange = repEnd - waveStats.repStart;
        const repColor = repChange >= 0 ? "#44ff44" : "#ff4444";
        const repSign = repChange >= 0 ? "+" : "";
        
        // Shop rep changes - only show shops that changed
        const shopRepLines = shops.map((shop, i) => {
          const startRep = waveStats.shopRepStart[i] ?? shop.rep;
          const change = shop.rep - startRep;
          if(Math.abs(change) < 0.1) return null;
          const color = change >= 0 ? "#44ff44" : "#ff4444";
          const sign = change >= 0 ? "+" : "";
          return `<span style="color:${color}">${shop.name}: ${sign}${change.toFixed(1)}</span>`;
        }).filter(Boolean);
        
        return `
          Mall: <span style="color:${repColor}">${repSign}${repChange.toFixed(1)}</span> (now ${repEnd.toFixed(0)})<br>
          ${shopRepLines.length > 0 ? shopRepLines.join("<br>") : "<span class='muted'>No shop rep changes</span>"}
        `;
      })()}
    `;
  } else {
    // Planning phase with no previous wave - show forecast
    const projSalary = getTotalSalaryPerSec() * waveLength;
    const shopS = getShopSalaryPerSec();
    const secS = (getGuardSalaryPerSec() + getCCTVSalaryPerSec()) * getRepSalaryMultiplier();
    const mult = getRepSalaryMultiplier();
    document.getElementById("analyticsPanel").innerHTML = `
      <b>Wave ${waveNumber} Forecast</b><br><br>
      <b>Estimated Salary Cost</b><br>
      Total: ¬£${projSalary.toFixed(0)} over ${waveLength}s<br>
      <span class="muted" style="font-size:10px">
        Staff: ¬£${(shopS * waveLength).toFixed(0)}
        ¬∑ Security: ¬£${(secS * waveLength).toFixed(0)}${mult > 1.0 ? ` (√ó${mult.toFixed(2)} rep)` : ''}
      </span><br><br>
      ${crewKnowledge > 0 || flashMobKnowledge > 0 ? `
      <b>‚ö† Known Threats</b><br>
      ${flashMobKnowledge > 0 ? `<span style="color:#ff9800">‚ö° Flash Mob: intel ${flashMobKnowledge}/10</span><br>` : ''}
      ${crewKnowledge > 0 ? `<span style="color:#9c27b0">üéØ Crew: intel ${crewKnowledge}/10 ¬∑ ${2 + Math.floor(crewKnowledge/4)} operatives</span><br>` : ''}
      ` : '<span class="muted">No organised threats detected yet.</span>'}
    `;
  }

  // Update mobile stats bar + drawer
  updateMobileStats();
}

/* ======================
   GAME LOOP
====================== */
let last=0;
function loop(t){
  const dt=(t-last)/1000;
  last=t;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

// Build UI and start
buildSelectedShopUI();
buildCCTVUI(); updateCameraButton();
setRightMode("wave");
checkShopUnlocks(); // Check for any unlocks at start
loop(0);
</script>
</body>
</html>
